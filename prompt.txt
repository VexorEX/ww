in tamam module haii hast ke az on handler estefade kardan

import { Composer, Markup } from 'telegraf';
import type { CustomContext } from '../middlewares/userAuth';
import config from '../config/config.json';
import more from '../config/more.json';
import { prisma } from '../prisma';
import { changeUserField } from './economy';

const shop = new Composer<CustomContext>();

const shopCategories = [
    { name: 'ğŸŒ Ø²Ù…ÛŒÙ†ÛŒ', callback: 'buy_ground' },
    { name: 'ğŸŒŠ Ø¯Ø±ÛŒØ§ÛŒÛŒ', callback: 'buy_marine' },
    { name: 'âœˆï¸ Ù‡ÙˆØ§ÛŒÛŒ', callback: 'buy_aerial' },
    { name: 'ğŸ›¡ Ø¯ÙØ§Ø¹ÛŒ', callback: 'buy_defence' }
];

const shopActions = [
    { name: 'ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', callback: 'back_main' },
    { name: 'âŒ Ø¨Ø³ØªÙ†', callback: 'delete' }
];

function chunk<T>(arr: T[], size: number): T[][] {
    const result: T[][] = [];
    for (let i = 0; i < arr.length; i += size) {
        result.push(arr.slice(i, i + size));
    }
    return result;
}

const keyboard = Markup.inlineKeyboard([
    ...chunk(shopCategories, 2).map(pair =>
        pair.map(c => Markup.button.callback(c.name, c.callback))
    ),
    shopActions.map(a => Markup.button.callback(a.name, a.callback))
]);

shop.action('shop', async (ctx) => {
    await ctx.reply('ğŸ›’ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:', keyboard);
    ctx.answerCbQuery();
});

function parsePrice(priceStr: string, qty: number): Record<string, number> {
    const parts = priceStr.split('+');
    const result: Record<string, number> = {};
    for (const part of parts) {
        const match = part.match(/(\d+)\((\w+)\)/);
        if (match) {
            const amount = Number(match[1]) * qty;
            const resource = match[2];
            result[resource] = (result[resource] || 0) + amount;
        }
    }
    return result;
}

function checkResources(user: any, cost: Record<string, number>): string[] {
    const lacks: string[] = [];
    for (const [res, amount] of Object.entries(cost)) {
        const current = BigInt(user[res] || 0);
        if (current < BigInt(amount)) lacks.push(`${res}: Ù†ÛŒØ§Ø² Ø¨Ù‡ ${amount}`);
    }
    return lacks;
}

function buildShopKeyboard(category: keyof typeof config.manage.shop.prices): Markup.Markup<any> {
    const prices = config.manage.shop.prices[category];
    const labels = more.armyLabels?.[category] || {};
    const rows: any[] = [];

    for (const [key, price] of Object.entries(prices)) {
        const label = labels[key] || key;
        const priceFa = price
            .replace(/iron/g, 'Ø¢Ù‡Ù†')
            .replace(/oil/g, 'Ù†ÙØª')
            .replace(/crowd/g, 'Ø¬Ù…Ø¹ÛŒØª')
            .replace(/capital/g, 'Ø³Ø±Ù…Ø§ÛŒÙ‡');

        rows.push([
            Markup.button.callback(label, 'noop'),
            Markup.button.callback(priceFa, 'noop'),
            Markup.button.callback('ğŸ›’ Ø®Ø±ÛŒØ¯', `buy_confirm_${category}_${key}`)
        ]);
    }

    rows.push(shopActions.map(a => Markup.button.callback(a.name, a.callback)));
    return Markup.inlineKeyboard(rows);
}

shop.action(/^buy_(ground|marine|aerial|defence)$/, async (ctx) => {
    const category = ctx.match[1] as keyof typeof config.manage.shop.prices;
    const keyboard = buildShopKeyboard(category);
    await ctx.reply(`ğŸ›’ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ÛŒ Ø¯Ø³ØªÙ‡ ${category} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:`, keyboard);
    ctx.answerCbQuery();
});

shop.action(/^buy_confirm_(ground|marine|aerial|defence)_(\w+)$/, async (ctx) => {
    const category = ctx.match[1];
    const item = ctx.match[2];

    ctx.session ??= {};
    ctx.session.buyStep = 'awaiting_quantity';
    ctx.session.buyCategory = category;
    ctx.session.buyItem = item;

    await ctx.reply(`ğŸ”¢ ØªØ¹Ø¯Ø§Ø¯ "${item}" Ù…ÙˆØ±Ø¯Ù†Ø¸Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†:`);
    ctx.answerCbQuery();
});

shop.on('text', async (ctx, next) => {
    ctx.session ??= {};
    if (ctx.session.buyStep !== 'awaiting_quantity') return next();

    const qty = Number(ctx.message.text.trim());
    if (isNaN(qty) || qty <= 0) return ctx.reply('âŒ ØªØ¹Ø¯Ø§Ø¯ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.');

    const { buyCategory, buyItem } = ctx.session;
    const priceStr = config.manage.shop.prices[buyCategory]?.[buyItem];
    if (!priceStr) return ctx.reply('âŒ Ø¢ÛŒØªÙ… ÛŒØ§ÙØª Ù†Ø´Ø¯.');

    const cost = parsePrice(priceStr, qty);
    const user = await prisma.user.findUnique({ where: { userid: BigInt(ctx.from.id) } });
    if (!user) return ctx.reply('âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯.');

    const lacks = checkResources(user, cost);
    if (lacks.length > 0) {
        return ctx.reply(`â›” Ù…Ù†Ø§Ø¨Ø¹ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª:\n${lacks.map(r => `â€¢ ${r}`).join('\n')}`);
    }

    for (const [res, amount] of Object.entries(cost)) {
        const result = await changeUserField(BigInt(ctx.from.id), res as any, 'subtract', amount);
        if (result !== 'ok') return ctx.reply(`âŒ Ø®Ø·Ø§ Ø¯Ø± Ú©Ù… Ú©Ø±Ø¯Ù† ${res}`);
    }
    const addResult = await changeUserField(BigInt(ctx.from.id), buyItem as any, 'add', qty);
    if (addResult !== 'ok') return ctx.reply(`âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÙØ²ÙˆØ¯Ù† Ø¢ÛŒØªÙ… "${buyItem}" Ø¨Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒ.`);

    const label = more.armyLabels?.[buyCategory]?.[buyItem] || buyItem;
    await ctx.reply(
        `âœ… Ø®Ø±ÛŒØ¯ ${qty} Ø¹Ø¯Ø¯ "${label}" Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯.\n` +
        `ğŸ“‰ Ù…Ù†Ø§Ø¨Ø¹ Ù…ØµØ±Ùâ€ŒØ´Ø¯Ù‡:\n` +
        Object.entries(cost)
            .map(([k, v]) => `â€¢ ${v} ${k === 'iron' ? 'Ø¢Ù‡Ù†' : k === 'oil' ? 'Ù†ÙØª' : k === 'crowd' ? 'Ø¬Ù…Ø¹ÛŒØª' : k === 'capital' ? 'Ø³Ø±Ù…Ø§ÛŒÙ‡' : k}`)
            .join('\n')
    );

    delete ctx.session.buyStep;
    delete ctx.session.buyCategory;
    delete ctx.session.buyItem;
});

export default shop;


import { Composer, Markup } from 'telegraf';
import type { CustomContext } from '../middlewares/userAuth';
import { escapeMarkdownV2 } from '../utils/escape';
import config from '../config/config.json';
import { changeCapital } from "./economy";

const admins :number[] = config.manage.state.admins;
const state = new Composer<CustomContext>();
const isstateAdmin = (id: number) => admins.includes(id);


state.action('state', async (ctx) => {
    ctx.session ??= {};
    ctx.session.awaitingstateImage = true;
    await ctx.reply('ğŸ–¼ Ù„Ø·ÙØ§Ù‹ ØªØµÙˆÛŒØ± Ø¨ÛŒØ§Ù†ÛŒÙ‡ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.');
    ctx.answerCbQuery();
});

state.on('photo', async (ctx, next) => {
    if (!ctx.session?.awaitingstateImage) {
        return next();
    }

    const photo = ctx.message.photo?.at(-1);
    if (!photo) {
        return ctx.reply('âŒ ØªØµÙˆÛŒØ± Ù…Ø¹ØªØ¨Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯.');
    }

    ctx.session.stateImageFileId = photo.file_id;
    ctx.session.awaitingstateImage = false;
    ctx.session.awaitingstateText = true;

    await ctx.reply('âœï¸ Ø­Ø§Ù„Ø§ Ù…ØªÙ† Ø¨ÛŒØ§Ù†ÛŒÙ‡ Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯ (Ø­Ø¯Ø§Ù‚Ù„ Û±Û°Û° Ú©Ø§Ø±Ø§Ú©ØªØ±).');
});
state.on('text', async (ctx, next) => {
    if (!ctx.session?.awaitingstateText) return next();

    const text = ctx.message.text.trim();
    if (text.length < 100) {
        return await ctx.reply('âŒ Ù…ØªÙ† Ø¨ÛŒØ§Ù†ÛŒÙ‡ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ Û±Û°Û° Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯.');
    }

    ctx.session.stateText = text;
    ctx.session.awaitingstateText = false;

 // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ quote ÙˆØ§Ù‚Ø¹ÛŒ
    const quotedText = escapeMarkdownV2(ctx.session.stateText
        .split('\n')
        .map(line => `> ${line}`)
        .join('\n'));
    const preview = `
ğŸ“£ *Ø¨ÛŒØ§Ù†ÛŒÙ‡ Ø±Ø³Ù…ÛŒ*
ØµØ§Ø¯Ø± Ø´Ø¯Ù‡ Ø§Ø² Ø³ÙˆÛŒ Ø¯ÙˆÙ„Øª *${ctx.user?.countryName}* ğŸ“

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

${quotedText}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Ø§Ø² Ø·Ø±Ù: ${ctx.from.username ? `@${escapeMarkdownV2(ctx.from.username)}` : `ID: ${ctx.from.id}`}
`;

    const confirmKeyboard = Markup.inlineKeyboard([
        [Markup.button.callback('âœ… ØªØ£ÛŒÛŒØ¯ Ùˆ Ø§Ø±Ø³Ø§Ù„', 'confirm_state')],
        [Markup.button.callback('âŒ Ù„ØºÙˆ', 'cancel_state')]
    ]);
    await ctx.replyWithPhoto(ctx.session.stateImageFileId, {
        caption: preview,
        parse_mode: 'MarkdownV2',
        reply_markup: confirmKeyboard.reply_markup
    });


});
state.action('confirm_state', async (ctx) => {
    const { stateImageFileId, stateText } = ctx.session ?? {};

    const senderId = ctx.from.id;
    const stateActionsKeyboard = Markup.inlineKeyboard([
        [Markup.button.callback('ğŸ—‘ Ø­Ø°Ù Ø¨ÛŒØ§Ù†ÛŒÙ‡', `delete_state_${senderId}`),
            Markup.button.callback('ğŸ’¸ Ø¬Ø±ÛŒÙ…Ù‡', `fine_state_${senderId}`)]
    ]);


    if (!stateImageFileId || !stateText || !ctx.user?.countryName) {
        return ctx.answerCbQuery('âŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù†Ø§Ù‚Øµ Ø§Ø³Øª!');
    }

    const quotedText = escapeMarkdownV2(ctx.session.stateText
  .split('\n')
  .map(line => `> ${line}`)
  .join('\n'));

    const finalText = `
ğŸ“£ *Ø¨ÛŒØ§Ù†ÛŒÙ‡ Ø±Ø³Ù…ÛŒ*
ØµØ§Ø¯Ø± Ø´Ø¯Ù‡ Ø§Ø² Ø³ÙˆÛŒ Ø¯ÙˆÙ„Øª *${ctx.user?.countryName}* ğŸ“

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

${quotedText}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Ø§Ø² Ø·Ø±Ù: ${ctx.from.username ? `@${escapeMarkdownV2(ctx.from.username)}` : `ID: ${ctx.from.id}`}
`;

    try {
        const sent = await ctx.telegram.sendPhoto(config.channels.state, stateImageFileId, {
            caption: finalText,
            reply_markup: stateActionsKeyboard.reply_markup,
            parse_mode: 'MarkdownV2'
        });
        ctx.session.laststateMessageId = sent.message_id;

        await ctx.reply('âœ… Ø¨ÛŒØ§Ù†ÛŒÙ‡ Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.');
    } catch (err) {
        console.error('Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ø¨ÛŒØ§Ù†ÛŒÙ‡:', err);
        await ctx.reply('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ø¨ÛŒØ§Ù†ÛŒÙ‡. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.');
        return ctx.answerCbQuery('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ø¨ÛŒØ§Ù†ÛŒÙ‡');
    }

    // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† session
    ctx.session.stateImageFileId = undefined;
    ctx.session.stateText = undefined;
    ctx.session.awaitingstateImage = false;
    ctx.session.awaitingstateText = false;
    ctx.answerCbQuery();
});
state.action('cancel_state', async (ctx) => {
    // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ú©Ø§Ù…Ù„ session
    ctx.session.stateImageFileId = undefined;
    ctx.session.stateText = undefined;
    ctx.session.awaitingstateImage = false;
    ctx.session.awaitingstateText = false;
    await ctx.reply('âŒ Ø§Ø±Ø³Ø§Ù„ Ø¨ÛŒØ§Ù†ÛŒÙ‡ Ù„ØºÙˆ Ø´Ø¯.');
    ctx.answerCbQuery();
});
state.action(/fine_state_(\d+)/, async (ctx) => {
    const senderId = BigInt(ctx.match[1]);
    const adminId = ctx.from.id;

    if (!isstateAdmin(adminId)) {
        return ctx.answerCbQuery('â›” ÙÙ‚Ø· Ø§Ø¯Ù…ÛŒÙ† Ø¨ÛŒØ§Ù†ÛŒÙ‡ Ù…ÛŒâ€ŒØªÙˆÙ†Ù‡ Ø¬Ø±ÛŒÙ…Ù‡ Ú©Ù†Ù‡.');
    }

    const fineAmount = Math.round(300 + Math.random() * 200); // Ø¨ÛŒÙ† 300 ØªØ§ 500

    const result = await changeCapital(senderId, 'subtract', fineAmount * 1_000_000); // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ù…ÛŒÙ„ÛŒÙˆÙ†

    if (result === 'not_found') {
        return ctx.answerCbQuery('âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯.');
    }

    if (result === 'invalid' || result === 'error') {
        return ctx.answerCbQuery('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¹Ù…Ø§Ù„ Ø¬Ø±ÛŒÙ…Ù‡.');
    }

    try {
        await ctx.telegram.sendMessage(Number(senderId), `ğŸ’¸ Ø´Ù…Ø§ ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ† Ø¨ÛŒØ§Ù†ÛŒÙ‡ Ø¬Ø±ÛŒÙ…Ù‡ Ø´Ø¯ÛŒØ¯ Ø¨Ù‡ Ù…Ø¨Ù„Øº ${fineAmount}M. Ø§Ø² Ø³Ø±Ù…Ø§ÛŒÙ‡ Ø´Ù…Ø§ Ú©Ø³Ø± Ø´Ø¯.`);
    } catch (err) {
        console.warn('Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¬Ø±ÛŒÙ…Ù‡ Ø¨Ù‡ PV Ú©Ø§Ø±Ø¨Ø± Ù…Ù…Ú©Ù† Ù†Ø¨ÙˆØ¯:', err);
    }
    await ctx.answerCbQuery(`âœ… Ø¬Ø±ÛŒÙ…Ù‡ ${fineAmount}M Ø§Ø¹Ù…Ø§Ù„ Ø´Ø¯.`);
});
state.action(/delete_state_(\d+)/, async (ctx) => {
    const senderId = Number(ctx.match[1]);
    const requesterId = ctx.from.id;
    const messageId = ctx.callbackQuery.message?.message_id;

    if (!messageId) {
        return ctx.answerCbQuery('âŒ Ù¾ÛŒØ§Ù… Ù‚Ø§Ø¨Ù„ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ù†ÛŒØ³Øª.');
    }

    if (requesterId !== senderId && !isstateAdmin(requesterId)) {
        return ctx.answerCbQuery('â›” ÙÙ‚Ø· Ø§Ø±Ø³Ø§Ù„â€ŒÚ©Ù†Ù†Ø¯Ù‡ ÛŒØ§ Ø§Ø¯Ù…ÛŒÙ† Ù…ÛŒâ€ŒØªÙˆÙ†Ù‡ Ø­Ø°Ù Ú©Ù†Ù‡.');
    }

    try {
        await ctx.telegram.deleteMessage(config.channels.state, messageId);
    } catch (err) {
        console.error('Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù¾ÛŒØ§Ù…:', err);
        return ctx.answerCbQuery('âŒ Ø­Ø°Ù Ù¾ÛŒØ§Ù… Ù…Ù…Ú©Ù† Ù†Ø¨ÙˆØ¯.');
    }

    const msg = requesterId === senderId
        ? 'âœ… Ø¨ÛŒØ§Ù†ÛŒÙ‡ ØªÙˆØ³Ø· Ø®ÙˆØ¯ØªØ§Ù† Ø­Ø°Ù Ø´Ø¯.'
        : 'âœ… Ø¨ÛŒØ§Ù†ÛŒÙ‡ ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ† Ø­Ø°Ù Ø´Ø¯.';

    await ctx.answerCbQuery(msg);
    // Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø¨Ù‡ ÙØ±Ø³ØªÙ†Ø¯Ù‡ Ø¯Ø± PV
    const notifyText = requesterId === senderId
        ? 'ğŸ“¢ Ø¨ÛŒØ§Ù†ÛŒÙ‡â€ŒØ§ÛŒ Ú©Ù‡ Ø§Ø±Ø³Ø§Ù„ Ú©Ø±Ø¯Ù‡ Ø¨ÙˆØ¯ÛŒ ØªÙˆØ³Ø· Ø®ÙˆØ¯Øª Ø­Ø°Ù Ø´Ø¯.'
        : 'ğŸ“¢ Ø¨ÛŒØ§Ù†ÛŒÙ‡â€ŒØ§ÛŒ Ú©Ù‡ Ø§Ø±Ø³Ø§Ù„ Ú©Ø±Ø¯Ù‡ Ø¨ÙˆØ¯ÛŒ ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ† Ø­Ø°Ù Ø´Ø¯.';

    try {
        await ctx.telegram.sendMessage(senderId, notifyText);
    } catch (err) {
        console.warn('Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ PV Ú©Ø§Ø±Ø¨Ø± Ù…Ù…Ú©Ù† Ù†Ø¨ÙˆØ¯:', err);
    }
});


export default state;


import { Composer, Markup } from 'telegraf';
import type { CustomContext } from '../middlewares/userAuth';
import { escapeMarkdownV2 } from '../utils/escape';
import { prisma } from '../prisma';
import config from '../config/config.json';
import { createProductionLine } from "./helper/Building";
import { changeCapital } from "./economy";
const admins: number[] = config.manage.buildings.admins;
const building = new Composer<CustomContext>();

// Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ø³Ø§Ø®Øªâ€ŒÙˆØ³Ø§Ø²
building.action('building', async (ctx) => {
    const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('ğŸš— Ø®ÙˆØ¯Ø±ÙˆØ³Ø§Ø²ÛŒ', 'build_car')],
        [Markup.button.callback('ğŸ™ Ø´Ù‡Ø±Ø³Ø§Ø²ÛŒ âŒ', 'NA')],
        [Markup.button.callback('ğŸ¬ ÙÛŒÙ„Ù…â€ŒØ³Ø§Ø²ÛŒ âŒ', 'NA')],
        [Markup.button.callback('ğŸ® Ø¨Ø§Ø²ÛŒâ€ŒØ³Ø§Ø²ÛŒ âŒ', 'NA')],
        [Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'back_main'), Markup.button.callback('âŒ Ø¨Ø³ØªÙ†', 'delete')]
    ]);

    await ctx.reply('ğŸ— Ù†ÙˆØ¹ Ø³Ø§Ø®Øªâ€ŒÙˆØ³Ø§Ø² Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:', keyboard);
    ctx.answerCbQuery();
});

// Ø´Ø±ÙˆØ¹ ÙØ±Ø¢ÛŒÙ†Ø¯ Ø³Ø§Ø®Øª Ø®ÙˆØ¯Ø±Ùˆ
building.action('build_car', async (ctx) => {
    const userId = BigInt(ctx.from.id);
    const setupCost = 250_000_000;

    const user = await prisma.user.findUnique({ where: { userid: userId } });
    if (!user) return ctx.reply('âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯.');
    const pending = await prisma.pendingProductionLine.findUnique({ where: { ownerId: userId } });

    if (pending) {
        const oneHourAgo = Date.now() - 60 * 60 * 1000;
        const requestTime = ctx.session.buildingRequestTime ?? 0;

        if (requestTime < oneHourAgo) {
            // Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† Ø³Ø±Ù…Ø§ÛŒÙ‡
            const refund = await changeCapital(userId, 'add', Number(pending.setupCost));
            if (refund === 'not_found') {
                await ctx.reply('âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯ Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ú¯Ø´Øª Ø³Ø±Ù…Ø§ÛŒÙ‡.');
            } else if (refund === 'invalid' || refund === 'error') {
                await ctx.reply('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²Ú¯Ø´Øª Ø³Ø±Ù…Ø§ÛŒÙ‡.');
            } else {
                await ctx.reply(`âŒ› Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù‚Ø¨Ù„ÛŒ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯ Ùˆ Ù…Ø¨Ù„Øº ${Number(pending.setupCost / BigInt(1_000_000)).toLocaleString()}M Ø¨Ù‡ Ø­Ø³Ø§Ø¨ Ø´Ù…Ø§ Ø¨Ø±Ú¯Ø´Øª.`);
            }

            await prisma.pendingProductionLine.delete({ where: { ownerId: userId } });
            ctx.session.buildingUsedToday = false;
            ctx.session.lastBuildDate = undefined;
            ctx.session.buildingRequestTime = undefined;
            return;
        } else {
            return ctx.reply('â›” Ù‡Ù†ÙˆØ² Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù‚Ø¨Ù„ÛŒ Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø±Ø±Ø³ÛŒÙ‡. Ù„Ø·ÙØ§Ù‹ ØµØ¨Ø± Ú©Ù† ÛŒØ§ Ø¨Ø¹Ø¯Ø§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†.');
        }
    }


    // Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø³Ø§Ø®Øªâ€ŒÙˆØ³Ø§Ø² Ø±ÙˆØ²Ø§Ù†Ù‡
    ctx.session ??= {};
    if (ctx.session.buildingUsedToday) {
        return ctx.reply('â›” Ø´Ù…Ø§ Ø§Ù…Ø±ÙˆØ² Ù‚Ø¨Ù„Ø§Ù‹ Ø³Ø§Ø®Øªâ€ŒÙˆØ³Ø§Ø² Ø§Ù†Ø¬Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒØ¯. Ù„Ø·ÙØ§Ù‹ ÙØ±Ø¯Ø§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.');
    }
    const today = new Date().toDateString();
    ctx.session ??= {};

    if (ctx.session.lastBuildDate === today) {
        return ctx.reply('â›” Ø´Ù…Ø§ Ø§Ù…Ø±ÙˆØ² Ù‚Ø¨Ù„Ø§Ù‹ Ø³Ø§Ø®Øªâ€ŒÙˆØ³Ø§Ø² Ø§Ù†Ø¬Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒØ¯. Ù„Ø·ÙØ§Ù‹ ÙØ±Ø¯Ø§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.');
    }

    if (user.capital < setupCost) {
        return ctx.reply(`âŒ Ø¨ÙˆØ¯Ø¬Ù‡ Ú©Ø§ÙÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯!\nğŸ’° Ø¨ÙˆØ¯Ø¬Ù‡ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²: ${(setupCost / 1_000_000).toLocaleString()}M\nğŸ’³ Ø¨ÙˆØ¯Ø¬Ù‡ ÙØ¹Ù„ÛŒ Ø´Ù…Ø§: ${Number(user.capital / BigInt(1_000_000)).toLocaleString()}M`);
    }

    ctx.session ??= {};
    ctx.session.buildingType = 'car';
    ctx.session.buildingStep = 'awaiting_car_name';
    ctx.session.setupCost = setupCost;
    await ctx.reply('ğŸš— Ù†Ø§Ù… Ù…Ø­ØµÙˆÙ„ Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†:');
    ctx.answerCbQuery();
});
// Ø¯Ø±ÛŒØ§ÙØª Ù†Ø§Ù… Ø®ÙˆØ¯Ø±Ùˆ
building.on('text', async (ctx, next) => {
    ctx.session ??= {};
    if (ctx.session.buildingStep === 'awaiting_car_name') {
        const name = ctx.message.text?.trim();
        if (!name || name.length < 2) {
            return ctx.reply('âŒ Ù†Ø§Ù… Ù…Ø­ØµÙˆÙ„ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†.');
        }

        ctx.session.carName = name;
        ctx.session.buildingStep = 'awaiting_car_image';
        await ctx.reply('ğŸ–¼ Ø­Ø§Ù„Ø§ ØªØµÙˆÛŒØ± Ù…Ø­ØµÙˆÙ„ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†:');
    } else {
        return next();
    }

});
// Ø¯Ø±ÛŒØ§ÙØª ØªØµÙˆÛŒØ± Ø®ÙˆØ¯Ø±Ùˆ Ùˆ Ù†Ù…Ø§ÛŒØ´ Ù¾ÛŒØ´â€ŒÙ†Ù…Ø§ÛŒØ´
building.on('photo', async (ctx, next) => {
    ctx.session ??= {};
    if (ctx.session.buildingStep !== 'awaiting_car_image') return next();

    const photo = ctx.message.photo?.at(-1);
    if (!photo) return ctx.reply('âŒ ØªØµÙˆÛŒØ± Ù…Ø¹ØªØ¨Ø± Ø§Ø±Ø³Ø§Ù„ Ù†Ø´Ø¯Ù‡.');

    const imageUrl = await ctx.telegram.getFileLink(photo.file_id);
    ctx.session.carImage = imageUrl.href;

    ctx.session.buildingStep = 'awaiting_build_description';
    await ctx.reply('ğŸ“ ØªÙˆØ¶ÛŒØ­ÛŒ Ø¯Ø±Ø¨Ø§Ø±Ù‡ Ù…Ø­ØµÙˆÙ„Øª Ø¨Ù†ÙˆÛŒØ³ (Ù…Ø«Ù„Ø§Ù‹ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ ÛŒØ§ Ù‡Ø¯Ù ØªÙˆÙ„ÛŒØ¯):');

    ctx.session.carImageFileId = photo.file_id;

    ctx.session.buildingStep = 'awaiting_admin_review';
});
building.on('text', async (ctx, next) => {
    ctx.session ??= {};
    if (ctx.session.buildingStep === 'awaiting_build_description') {
        const description = ctx.message.text?.trim();
        if (!description || description.length < 5) {
            return ctx.reply('âŒ ØªÙˆØ¶ÛŒØ­ Ø®ÛŒÙ„ÛŒ Ú©ÙˆØªØ§Ù‡Ù‡. Ù„Ø·ÙØ§Ù‹ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù‡.');
        }

        ctx.session.buildingDescription = description;
        ctx.session.buildingStep = 'awaiting_admin_review';

        const preview = escapeMarkdownV2(
            `ğŸ­ Ù¾ÛŒØ´â€ŒÙ†Ù…Ø§ÛŒØ´ Ø®Ø· ØªÙˆÙ„ÛŒØ¯ Ø®ÙˆØ¯Ø±Ùˆ\n\n` +
            `> Ú©Ø´ÙˆØ± Ø³Ø§Ø²Ù†Ø¯Ù‡: **${ctx.user?.countryName}**\n` +
            `> Ù…Ø­ØµÙˆÙ„: **${ctx.session.carName}**\n` +
            `> ØªÙˆØ¶ÛŒØ­: ${ctx.session.buildingDescription}\n\n` +
            `Ø¨ÙˆØ¯Ø¬Ù‡ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ: 250M\nØ¸Ø±ÙÛŒØª ØªÙˆÙ„ÛŒØ¯ Ø±ÙˆØ²Ø§Ù†Ù‡: 15 Ø®ÙˆØ¯Ø±Ùˆ\n\n` +
            `âœ… Ø§Ú¯Ø± ØªØ£ÛŒÛŒØ¯ Ù…ÛŒâ€ŒÚ©Ù†ÛŒØŒ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ø±Ø§ Ø¨Ø²Ù† ØªØ§ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø§Ø±Ø³Ø§Ù„ Ø´ÙˆØ¯.`
        );

        const confirmKeyboard = Markup.inlineKeyboard([
            [Markup.button.callback('âœ… Ø§Ø±Ø³Ø§Ù„ Ø¨Ø±Ø§ÛŒ ØªØ£ÛŒÛŒØ¯ Ø§Ø¯Ù…ÛŒÙ†', 'submit_building')],
            [Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'building')]
        ]);

        await ctx.replyWithPhoto(ctx.session.carImageFileId, {
            caption: preview,
            parse_mode: 'MarkdownV2',
            reply_markup: confirmKeyboard.reply_markup
        });
    } else {
        return next();
    }
});

// Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ù‡ Ø§Ø¯Ù…ÛŒÙ†
building.action('submit_building', async (ctx) => {
    ctx.session ??= {};
    ctx.session.buildingUsedToday = true;
    ctx.session.lastBuildDate = new Date().toDateString();
    ctx.session.buildingRequestTime = Date.now();

    const { carName, carImage, carImageFileId, setupCost } = ctx.session;
    const countryName = ctx.user?.countryName;
    const userId = BigInt(ctx.from.id);

    if (!carName || !carImage || !carImageFileId || !countryName || !setupCost) {
        return ctx.reply('âŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù†Ø§Ù‚Øµ Ø§Ø³Øª.');
    }

    // Ú©Ø³Ø± Ù¾ÙˆÙ„ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² changeCapital
    const result = await changeCapital(userId, 'subtract', setupCost);
    if (result === 'not_found') {
        return ctx.reply('âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯.');
    }
    if (result === 'invalid' || result === 'error') {
        return ctx.reply('âŒ Ø®Ø·Ø§ Ø¯Ø± Ú©Ø³Ø± Ù¾ÙˆÙ„.');
    }

    await prisma.pendingProductionLine.upsert({
        where: { ownerId: userId },
        update: {
            name: carName,
            type: 'car',
            imageUrl: carImage,
            imageFileId: carImageFileId,
            dailyLimit: 15,
            setupCost: BigInt(setupCost),
            country: countryName
        },
        create: {
            ownerId: userId,
            name: carName,
            type: 'car',
            imageUrl: carImage,
            imageFileId: carImageFileId,
            dailyLimit: 15,
            setupCost: BigInt(setupCost),
            country: countryName
        }
    });

    const adminKeyboard = Markup.inlineKeyboard([
        [Markup.button.callback('âœ… ØªØ£ÛŒÛŒØ¯ Ø³Ø§Ø®Øª', `admin_approve_building_${userId}`)],
        [Markup.button.callback('âŒ Ø±Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³Øª', `admin_reject_building_${userId}`)]
    ]);

    for (const admin of admins) {
        await ctx.telegram.sendPhoto(admin, carImageFileId, {
            caption: escapeMarkdownV2(
                `ğŸ“¥ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø³Ø§Ø®Øª Ø®Ø· ØªÙˆÙ„ÛŒØ¯ Ø®ÙˆØ¯Ø±Ùˆ\n\n` +
                `> Ú©Ø´ÙˆØ±: **${countryName}**\n` +
                `> Ù…Ø­ØµÙˆÙ„: **${carName}**\n` +
                `> ØªÙˆØ¶ÛŒØ­: ${ctx.session.buildingDescription}\n\n` +
                `Ø¨ÙˆØ¯Ø¬Ù‡: 250M\nØ¸Ø±ÙÛŒØª ØªÙˆÙ„ÛŒØ¯ Ø±ÙˆØ²Ø§Ù†Ù‡: 15 Ø®ÙˆØ¯Ø±Ùˆ`
            ),
            parse_mode: 'MarkdownV2',
            reply_markup: adminKeyboard.reply_markup
        });
    }

    await ctx.reply('ğŸ“¤ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø´Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.');
    ctx.session.buildingStep = undefined;
});
// ØªØ£ÛŒÛŒØ¯ Ù†Ù‡Ø§ÛŒÛŒ ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ†
building.action(/admin_approve_building_(\d+)/, async (ctx) => {
    const userId = BigInt(ctx.match[1]);

    const user = await prisma.user.findUnique({ where: { userid: userId } });
    if (!user) return ctx.reply('âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯.');

    const pending = await prisma.pendingProductionLine.findUnique({ where: { ownerId: userId } });
    if (!pending) return ctx.reply('âŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø­ØµÙˆÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯.');

    const result = await createProductionLine({
        ownerId: userId,
        country: pending.country,
        name: pending.name,
        type: pending.type,
        imageUrl: pending.imageUrl,
        dailyLimit: pending.dailyLimit,
        setupCost: pending.setupCost,
        carName: pending.name
    });

    if (result.error) return ctx.reply(result.error);

    await prisma.pendingProductionLine.delete({ where: { ownerId: userId } });

    await ctx.telegram.sendPhoto(config.channels.updates, pending.imageFileId, {
        caption: escapeMarkdownV2(
            `ğŸ­ Ø®Ø· ØªÙˆÙ„ÛŒØ¯ Ø¬Ø¯ÛŒØ¯ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¯\n\n` +
            `> Ú©Ø´ÙˆØ± Ø³Ø§Ø²Ù†Ø¯Ù‡: **${user.countryName}**\n` +
            `> Ù…Ø­ØµÙˆÙ„: **${pending.name}**\n\n` +
            `Ø¨ÙˆØ¯Ø¬Ù‡ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ: ${pending.setupCost.toLocaleString()} Ø±ÛŒØ§Ù„\n` +
            `Ø¸Ø±ÙÛŒØª ØªÙˆÙ„ÛŒØ¯ Ø±ÙˆØ²Ø§Ù†Ù‡: ${pending.dailyLimit} ÙˆØ§Ø­Ø¯`
        ),
        parse_mode: 'MarkdownV2'
    });

    await ctx.reply('âœ… Ø®Ø· ØªÙˆÙ„ÛŒØ¯ Ø«Ø¨Øª Ø´Ø¯ Ùˆ Ø¨Ù‡ Ú©Ø§Ù†Ø§Ù„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.');
});
// Ø±Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ†
building.action(/admin_reject_building_(\d+)/, async (ctx) => {
    const userId = BigInt(ctx.match[1]);
    const adminId = ctx.from.id;

    if (!admins.includes(adminId)) {
        return ctx.answerCbQuery('â›” ÙÙ‚Ø· Ø§Ø¯Ù…ÛŒÙ† Ù…ÛŒâ€ŒØªÙˆÙ†Ù‡ Ø±Ø¯ Ú©Ù†Ù‡.');
    }


    const pending = await prisma.pendingProductionLine.findUnique({ where: { ownerId: userId } });
    if (!pending) {
        return ctx.answerCbQuery('âŒ Ø¯Ø±Ø®ÙˆØ§Ø³Øª ÛŒØ§ÙØª Ù†Ø´Ø¯.');
    }

    // Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† Ù¾ÙˆÙ„
    const result = await changeCapital(userId, 'add', Number(pending.setupCost));
    if (result === 'not_found') {
        return ctx.answerCbQuery('âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯.');
    }
    if (result === 'invalid' || result === 'error') {
        return ctx.answerCbQuery('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† Ù¾ÙˆÙ„.');
    }

    // Ø­Ø°Ù Ø¯Ø±Ø®ÙˆØ§Ø³Øª
    await prisma.pendingProductionLine.delete({ where: { ownerId: userId } });

    // Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±
    try {
        await ctx.telegram.sendMessage(Number(userId),
            `âŒ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø³Ø§Ø®Øª Ø®Ø· ØªÙˆÙ„ÛŒØ¯ Ø´Ù…Ø§ Ø±Ø¯ Ø´Ø¯.\nğŸ’° Ù…Ø¨Ù„Øº ${Number(pending.setupCost / BigInt(1_000_000)).toLocaleString()}M Ø¨Ù‡ Ø­Ø³Ø§Ø¨ Ø´Ù…Ø§ Ø¨Ø±Ú¯Ø´Øª.`
        );
    } catch (err) {
        console.warn('Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ PV Ú©Ø§Ø±Ø¨Ø± Ù…Ù…Ú©Ù† Ù†Ø¨ÙˆØ¯:', err);
    }

    await ctx.answerCbQuery('âœ… Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø±Ø¯ Ø´Ø¯ Ùˆ Ù¾ÙˆÙ„ Ø¨Ø±Ú¯Ø´Øª.');
});

export default building;


import { Composer, Markup } from 'telegraf';
import type { CustomContext } from '../../middlewares/userAuth';
import { prisma } from '../../prisma';
import { assetCategories , bigintFields } from '../../constants/assetCategories';
import { calculateNewValue } from "../helper/calculate";
import {changeFieldForAllUsers, changeUserField ,Operation } from "../economy";

const editAsset = new Composer<CustomContext>();

const cancelBtn = Markup.inlineKeyboard([
    [Markup.button.callback('âŒ Ù„ØºÙˆ', 'cancel_edit')]
])


editAsset.on('text', async (ctx, next) => {
    ctx.session ??= {};
    if (!ctx.session || !ctx.session.editStep) {
        return next();
    }
    const valueStr = ctx.message.text;
    console.log(valueStr);
    // Ù…Ø±Ø­Ù„Ù‡ Ø¯Ø±ÛŒØ§ÙØª Ø´Ù†Ø§Ø³Ù‡ Ú©Ø§Ø±Ø¨Ø±
    if (ctx.session.editStep === 'awaiting_user_id') {
        if (!/^\d+$/.test(valueStr)) return ctx.reply('âŒ Ø´Ù†Ø§Ø³Ù‡ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.');
        ctx.session.editUserId = BigInt(valueStr);
        ctx.session.editStep = 'awaiting_category';

        const keyboard = Markup.inlineKeyboard([
            ...Object.entries(assetCategories).map(([key]) => [
                Markup.button.callback(`ğŸ“¦ ${key}`, `edit_cat_${key}`)
            ]),
            [Markup.button.callback('âŒ Ù„ØºÙˆ', 'cancel_edit')]
        ]);

        await ctx.reply('ğŸ”§ Ø¯Ø³ØªÙ‡ Ø¯Ø§Ø±Ø§ÛŒÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:', keyboard);
        return;
    }

    // Ù…Ø±Ø­Ù„Ù‡ Ø¯Ø±ÛŒØ§ÙØª Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±Ø¨Ø±
    if (ctx.session.editStep === 'awaiting_value') {
        const valueStr = ctx.message.text?.trim();
        const value = Number(valueStr?.replace(/[+-]/, ''));
        if (isNaN(value)) return ctx.reply('âŒ Ù…Ù‚Ø¯Ø§Ø± Ø¹Ø¯Ø¯ÛŒ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.');

        const { editUserId, editItem } = ctx.session;
        if (!editUserId || !editItem) return ctx.reply('âŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù†Ø§Ù‚Øµ Ø§Ø³Øª.');

        const operation: Operation =
            valueStr.startsWith('+') ? 'add'
                : valueStr.startsWith('-') ? 'subtract'
                    : 'set';

        const result = await changeUserField(editUserId, editItem, operation, value);

        if (result === 'ok') {
            await ctx.reply(`âœ… Ù…Ù‚Ø¯Ø§Ø± Ø¬Ø¯ÛŒØ¯ ${editItem} Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± ${editUserId} Ø§Ø¹Ù…Ø§Ù„ Ø´Ø¯.`);
        } else if (result === 'not_found') {
            await ctx.reply('âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯.');
        } else if (result === 'invalid') {
            await ctx.reply('âŒ Ø¹Ù…Ù„ÛŒØ§Øª Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø¨ÙˆØ¯.');
        } else {
            await ctx.reply('âŒ Ø®Ø·Ø§ Ø¯Ø± ÙˆÛŒØ±Ø§ÛŒØ´. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†.');
        }

        ctx.session.editStep = undefined;
        return;
    }

    // Ù…Ø±Ø­Ù„Ù‡ Ø¯Ø±ÛŒØ§ÙØª Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†
    if (ctx.session.editStep === 'awaiting_value_all') {
        const valueStr = ctx.message.text?.trim();
        const value = Number(valueStr?.replace(/[+-]/, ''));
        if (isNaN(value)) return ctx.reply('âŒ Ù…Ù‚Ø¯Ø§Ø± Ø¹Ø¯Ø¯ÛŒ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.');

        const { editItem } = ctx.session;
        const operation: Operation =
            valueStr.startsWith('+') ? 'add'
                : valueStr.startsWith('-') ? 'subtract'
                    : 'set';

        const result = await changeFieldForAllUsers(editItem, operation, value);

        if (result === 'ok') {
            await ctx.reply(`âœ… Ù…Ù‚Ø¯Ø§Ø± Ø¬Ø¯ÛŒØ¯ ${editItem} Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø§Ø¹Ù…Ø§Ù„ Ø´Ø¯.`);
        } else if (result === 'invalid') {
            await ctx.reply('âŒ Ø¹Ù…Ù„ÛŒØ§Øª Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø¨ÙˆØ¯.');
        } else {
            await ctx.reply('âŒ Ø®Ø·Ø§ Ø¯Ø± ÙˆÛŒØ±Ø§ÛŒØ´ Ú¯Ø±ÙˆÙ‡ÛŒ. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†.');
        }

        ctx.session.editStep = undefined;
        return;
    }

    console.log('ğŸ”¥ text received:', ctx.message.text);
    await ctx.reply('Ù…ØªÙ† Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.');
});

//
// âœ… ÙˆÛŒØ±Ø§ÛŒØ´ Ø¯Ø§Ø±Ø§ÛŒÛŒ Ø¨Ø§ /editasset
//
editAsset.action('admin_editAsset', async (ctx) => {
    ctx.session ??= {};
    ctx.session.editStep = 'awaiting_user_id';

    await ctx.reply('ğŸ“Œ Ù„Ø·ÙØ§Ù‹ Ø´Ù†Ø§Ø³Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†:\nÙ…Ø«Ø§Ù„: 7588477963');
    ctx.answerCbQuery();
});
editAsset.action(/^edit_cat_(\w+)$/, async (ctx) => {
    ctx.session ??= {};
    const category = ctx.match[1];
    const items = assetCategories[category];
    if (!items) return ctx.answerCbQuery('âŒ Ø¯Ø³ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.');

    ctx.session.editCategory = category;

    const keyboard = Markup.inlineKeyboard([
        ...items.map((item) => [Markup.button.callback(item, `edit_item_${item}`)]),
        [Markup.button.callback('âŒ Ù„ØºÙˆ', 'cancel_edit')]
    ]);


    try {
        await ctx.editMessageText('ğŸ” Ù…ÙˆØ±Ø¯ÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒ ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ù†ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:', keyboard);
    } catch (err) {
        console.error('âŒ Ø®Ø·Ø§ Ø¯Ø± editMessageText:', err);
        await ctx.reply('âŒ Ø®Ø·Ø§ Ø¯Ø± ÙˆÛŒØ±Ø§ÛŒØ´ Ù¾ÛŒØ§Ù…. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†.');
    }

    ctx.answerCbQuery();
});
editAsset.action(/^edit_item_(\w+)$/, async (ctx) => {
    ctx.session ??= {};
    ctx.session.editItem = ctx.match[1];
    ctx.session.editStep = 'awaiting_value';
    await ctx.reply('âœï¸ Ù…Ù‚Ø¯Ø§Ø± Ø¬Ø¯ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†:\n+25 Ø¨Ø±Ø§ÛŒ Ø§ÙØ²Ø§ÛŒØ´ØŒ -25 Ø¨Ø±Ø§ÛŒ Ú©Ø§Ù‡Ø´ØŒ 25 Ø¨Ø±Ø§ÛŒ Ù…Ù‚Ø¯Ø§Ø± Ù…Ø³ØªÙ‚ÛŒÙ…', cancelBtn);
    ctx.answerCbQuery();
});


editAsset.action('admin_editAssetAll', async (ctx) => {
    ctx.session ??= {};
    ctx.session.editStep = 'awaiting_category_all';

    const keyboard = Markup.inlineKeyboard([
        ...Object.entries(assetCategories).map(([key]) => [
            Markup.button.callback(`ğŸ“¦ ${key}`, `edit_all_cat_${key}`)
        ]),
        [Markup.button.callback('âŒ Ù„ØºÙˆ', 'cancel_edit')]
    ]);


    await ctx.reply('ğŸ“Š Ø¯Ø³ØªÙ‡ Ø¯Ø§Ø±Ø§ÛŒÛŒ Ø±Ø§ Ø¨Ø±Ø§ÛŒ ÙˆÛŒØ±Ø§ÛŒØ´ Ú¯Ø±ÙˆÙ‡ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:', keyboard);
    ctx.answerCbQuery();
});
editAsset.action(/^edit_all_cat_(\w+)$/, async (ctx) => {
    ctx.session ??= {};
    const category = ctx.match[1];
    const items = assetCategories[category];
    if (!items) return ctx.answerCbQuery('âŒ Ø¯Ø³ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.');

    ctx.session.editCategory = category;

    const keyboard = Markup.inlineKeyboard([
        ...items.map((item) => [Markup.button.callback(item, `edit_all_item_${item}`)]),
        [Markup.button.callback('âŒ Ù„ØºÙˆ', 'cancel_edit')]
    ]);


    try {
        await ctx.editMessageText('ğŸ” Ù…ÙˆØ±Ø¯ÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ù†ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:', keyboard);
    } catch (err) {
        console.error('âŒ Ø®Ø·Ø§ Ø¯Ø± editMessageText:', err);
        await ctx.reply('âŒ Ø®Ø·Ø§ Ø¯Ø± ÙˆÛŒØ±Ø§ÛŒØ´ Ù¾ÛŒØ§Ù…. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†.');
    }

    ctx.answerCbQuery();
});
editAsset.action(/^edit_all_item_(\w+)$/, async (ctx) => {
    ctx.session ??= {};
    ctx.session.editItem = ctx.match[1];
    ctx.session.editStep = 'awaiting_value_all';

    await ctx.reply('âœï¸ Ù…Ù‚Ø¯Ø§Ø± Ø¬Ø¯ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†:\n+25 Ø¨Ø±Ø§ÛŒ Ø§ÙØ²Ø§ÛŒØ´ØŒ -25 Ø¨Ø±Ø§ÛŒ Ú©Ø§Ù‡Ø´ØŒ 25 Ø¨Ø±Ø§ÛŒ Ù…Ù‚Ø¯Ø§Ø± Ù…Ø³ØªÙ‚ÛŒÙ…',cancelBtn);
    ctx.answerCbQuery();
});

editAsset.action('cancel_edit', async (ctx) => {
    ctx.session.editStep = undefined;
    await ctx.editMessageText('âŒ Ø¹Ù…Ù„ÛŒØ§Øª ÙˆÛŒØ±Ø§ÛŒØ´ Ù„ØºÙˆ Ø´Ø¯.',{});
    ctx.answerCbQuery();
});


export default editAsset;

