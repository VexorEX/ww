import { Composer, Markup } from 'telegraf';
import type { CustomContext } from '../middlewares/userAuth';
import { escapeMarkdownV2 } from '../utils/escape';
import { prisma } from '../prisma';
import config from '../config/config.json';
import { createProductionLine } from "./helper/Building";
import { changeCapital } from "./economy";
const admins: number[] = config.manage.buildings.admins;
const building = new Composer<CustomContext>();

// ŸÖŸÜŸà€å ÿßÿµŸÑ€å ÿ≥ÿßÿÆÿ™‚ÄåŸàÿ≥ÿßÿ≤
building.action('building', async (ctx) => {
    const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('üöó ÿÆŸàÿØÿ±Ÿàÿ≥ÿßÿ≤€å', 'build_car')],
        [Markup.button.callback('üé¨ ŸÅ€åŸÑŸÖ‚Äåÿ≥ÿßÿ≤€å', 'build_film')],
        [Markup.button.callback('üéµ ŸÖŸàÿ≤€å⁄©‚Äåÿ≥ÿßÿ≤€å', 'build_music')],
        [Markup.button.callback('üéÆ ÿ®ÿßÿ≤€å‚Äåÿ≥ÿßÿ≤€å', 'build_game')],
        [Markup.button.callback('üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™', 'back_main'), Markup.button.callback('‚ùå ÿ®ÿ≥ÿ™ŸÜ', 'delete')]
    ]);
    await ctx.reply('üèó ŸÜŸàÿπ ÿ≥ÿßÿÆÿ™‚ÄåŸàÿ≥ÿßÿ≤ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ:', keyboard);
    ctx.answerCbQuery();
});


// ÿ¥ÿ±Ÿàÿπ ŸÅÿ±ÿ¢€åŸÜÿØ ÿ≥ÿßÿÆÿ™ ÿÆŸàÿØÿ±Ÿà
building.action('build_car', async (ctx) => {
    const userId = BigInt(ctx.from.id);
    const setupCost = 250_000_000;

    const user = await prisma.user.findUnique({ where: { userid: userId } });
    if (!user) return ctx.reply('‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.');
    const pending = await prisma.pendingProductionLine.findFirst({ where: { ownerId: userId } });

    if (pending) {
        const oneHourAgo = Date.now() - 60 * 60 * 1000;
        const requestTime = ctx.session.buildingRequestTime ?? 0;

        if (requestTime < oneHourAgo) {
            // ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜÿØŸÜ ÿ≥ÿ±ŸÖÿß€åŸá
            const refund = await changeCapital(userId, 'add', Number(pending.setupCost));
            if (refund === 'not_found') {
                await ctx.reply('‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ ÿ®ÿ±ÿß€å ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ≥ÿ±ŸÖÿß€åŸá.');
            } else if (refund === 'invalid' || refund === 'error') {
                await ctx.reply('‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ≥ÿ±ŸÖÿß€åŸá.');
            } else {
                await ctx.reply(`‚åõ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ŸÇÿ®ŸÑ€å ŸÖŸÜŸÇÿ∂€å ÿ¥ÿØ Ÿà ŸÖÿ®ŸÑÿ∫ ${Number(pending.setupCost / BigInt(1_000_000)).toLocaleString()}M ÿ®Ÿá ÿ≠ÿ≥ÿßÿ® ÿ¥ŸÖÿß ÿ®ÿ±⁄Øÿ¥ÿ™.`);
            }

            await prisma.pendingProductionLine.deleteMany({ where: { ownerId: userId } });
            ctx.session.buildingUsedToday = false;
            ctx.session.lastBuildDate = undefined;
            ctx.session.buildingRequestTime = undefined;
            return;
        } else {
            return ctx.reply('‚õî ŸáŸÜŸàÿ≤ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ŸÇÿ®ŸÑ€å ÿØÿ± ÿ≠ÿßŸÑ ÿ®ÿ±ÿ±ÿ≥€åŸá. ŸÑÿ∑ŸÅÿßŸã ÿµÿ®ÿ± ⁄©ŸÜ €åÿß ÿ®ÿπÿØÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ.');
        }
    }


    // ÿ®ÿ±ÿ±ÿ≥€å ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ≥ÿßÿÆÿ™‚ÄåŸàÿ≥ÿßÿ≤ ÿ±Ÿàÿ≤ÿßŸÜŸá
    ctx.session ??= {};
    if (ctx.session.buildingUsedToday) {
        return ctx.reply('‚õî ÿ¥ŸÖÿß ÿßŸÖÿ±Ÿàÿ≤ ŸÇÿ®ŸÑÿßŸã ÿ≥ÿßÿÆÿ™‚ÄåŸàÿ≥ÿßÿ≤ ÿßŸÜÿ¨ÿßŸÖ ÿØÿßÿØŸá‚Äåÿß€åÿØ. ŸÑÿ∑ŸÅÿßŸã ŸÅÿ±ÿØÿß ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.');
    }
    const today = new Date().toDateString();
    ctx.session ??= {};

    if (ctx.session.lastBuildDate === today) {
        return ctx.reply('‚õî ÿ¥ŸÖÿß ÿßŸÖÿ±Ÿàÿ≤ ŸÇÿ®ŸÑÿßŸã ÿ≥ÿßÿÆÿ™‚ÄåŸàÿ≥ÿßÿ≤ ÿßŸÜÿ¨ÿßŸÖ ÿØÿßÿØŸá‚Äåÿß€åÿØ. ŸÑÿ∑ŸÅÿßŸã ŸÅÿ±ÿØÿß ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.');
    }

    if (user.capital < setupCost) {
        return ctx.reply(`‚ùå ÿ®ŸàÿØÿ¨Ÿá ⁄©ÿßŸÅ€å ŸÜÿØÿßÿ±€åÿØ!\nüí∞ ÿ®ŸàÿØÿ¨Ÿá ŸÖŸàÿ±ÿØ ŸÜ€åÿßÿ≤: ${(setupCost / 1_000_000).toLocaleString()}M\nüí≥ ÿ®ŸàÿØÿ¨Ÿá ŸÅÿπŸÑ€å ÿ¥ŸÖÿß: ${Number(user.capital / BigInt(1_000_000)).toLocaleString()}M`);
    }

    ctx.session ??= {};
    ctx.session.buildingType = 'car';
    ctx.session.buildingStep = 'awaiting_car_name';
    ctx.session.setupCost = setupCost;
    await ctx.reply('üöó ŸÜÿßŸÖ ŸÖÿ≠ÿµŸàŸÑ ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ:');
    ctx.answerCbQuery();
});
// ÿØÿ±€åÿßŸÅÿ™ ŸÜÿßŸÖ ÿÆŸàÿØÿ±Ÿà
building.on('text', async (ctx, next) => {
    ctx.session ??= {};
    if (['awaiting_car_name', 'awaiting_name'].includes(ctx.session.buildingStep)) {
        const name = ctx.message.text?.trim();
        if (!name || name.length < 2) {
            return ctx.reply('‚ùå ŸÜÿßŸÖ ŸÖÿ≠ÿµŸàŸÑ ŸÖÿπÿ™ÿ®ÿ± ŸÜ€åÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá Ÿàÿßÿ±ÿØ ⁄©ŸÜ.');
        }

        if (ctx.session.buildingType === 'car') {
            ctx.session.carName = name;
        } else {
            ctx.session.buildingName = name;
        }

        ctx.session.buildingStep = 'awaiting_car_image';
        await ctx.reply('üñº ÿ≠ÿßŸÑÿß ÿ™ÿµŸà€åÿ± ŸÖÿ≠ÿµŸàŸÑ ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ:');
    }


});
// ÿØÿ±€åÿßŸÅÿ™ ÿ™ÿµŸà€åÿ± ÿÆŸàÿØÿ±Ÿà Ÿà ŸÜŸÖÿß€åÿ¥ Ÿæ€åÿ¥‚ÄåŸÜŸÖÿß€åÿ¥
building.on('photo', async (ctx, next) => {
    ctx.session ??= {};
    if (ctx.session.buildingStep !== 'awaiting_car_image') return next();

    const photo = ctx.message.photo?.at(-1);
    if (!photo) return ctx.reply('‚ùå ÿ™ÿµŸà€åÿ± ŸÖÿπÿ™ÿ®ÿ± ÿßÿ±ÿ≥ÿßŸÑ ŸÜÿ¥ÿØŸá.');

    const imageUrl = await ctx.telegram.getFileLink(photo.file_id);
    ctx.session.carImage = imageUrl.href;

    await ctx.reply('üìù ÿ™Ÿàÿ∂€åÿ≠€å ÿØÿ±ÿ®ÿßÿ±Ÿá ŸÖÿ≠ÿµŸàŸÑÿ™ ÿ®ŸÜŸà€åÿ≥ (ŸÖÿ´ŸÑÿßŸã Ÿà€å⁄ò⁄Ø€å‚ÄåŸáÿß €åÿß ŸáÿØŸÅ ÿ™ŸàŸÑ€åÿØ):');

    ctx.session.carImageFileId = photo.file_id;

    ctx.session.buildingStep = 'awaiting_build_description';
});
building.on('text', async (ctx, next) => {
    ctx.session ??= {};
    if (ctx.session.buildingStep === 'awaiting_build_description') {
        const description = ctx.message.text;
        if (!description || description.length < 5) {
            return ctx.reply('‚ùå ÿ™Ÿàÿ∂€åÿ≠ ÿÆ€åŸÑ€å ⁄©Ÿàÿ™ÿßŸáŸá. ŸÑÿ∑ŸÅÿßŸã ÿ®€åÿ¥ÿ™ÿ± ÿ™Ÿàÿ∂€åÿ≠ ÿ®ÿØŸá.');
        }

        ctx.session.buildingDescription = description;
        ctx.session.buildingStep = 'awaiting_admin_review';

        const preview = escapeMarkdownV2(
            `üè≠ Ÿæ€åÿ¥‚ÄåŸÜŸÖÿß€åÿ¥ ÿÆÿ∑ ÿ™ŸàŸÑ€åÿØ ÿÆŸàÿØÿ±Ÿà\n\n` +
            `> ⁄©ÿ¥Ÿàÿ± ÿ≥ÿßÿ≤ŸÜÿØŸá: **${ctx.user?.countryName}**\n` +
            `> ŸÖÿ≠ÿµŸàŸÑ: **${ctx.session.carName}**\n` +
            `> ÿ™Ÿàÿ∂€åÿ≠: ${ctx.session.buildingDescription}\n\n` +
            `ÿ®ŸàÿØÿ¨Ÿá ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å: 250M\nÿ∏ÿ±ŸÅ€åÿ™ ÿ™ŸàŸÑ€åÿØ ÿ±Ÿàÿ≤ÿßŸÜŸá: 15 ÿÆŸàÿØÿ±Ÿà\n\n` +
            `‚úÖ ÿß⁄Øÿ± ÿ™ÿ£€å€åÿØ ŸÖ€å‚Äå⁄©ŸÜ€åÿå ÿØ⁄©ŸÖŸá ÿ≤€åÿ± ÿ±ÿß ÿ®ÿ≤ŸÜ ÿ™ÿß ÿ®ÿ±ÿß€å ÿ®ÿ±ÿ±ÿ≥€å ÿßÿØŸÖ€åŸÜ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ŸàÿØ.`
        );

        const confirmKeyboard = Markup.inlineKeyboard([
            [Markup.button.callback('‚úÖ ÿßÿ±ÿ≥ÿßŸÑ ÿ®ÿ±ÿß€å ÿ™ÿ£€å€åÿØ ÿßÿØŸÖ€åŸÜ', 'submit_building')],
            [Markup.button.callback('üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™', 'building')]
        ]);

        await ctx.replyWithPhoto(ctx.session.carImageFileId, {
            caption: preview,
            parse_mode: 'MarkdownV2',
            reply_markup: confirmKeyboard.reply_markup
        });
    } else {
        return next();
    }
});

// ÿßÿ±ÿ≥ÿßŸÑ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ®Ÿá ÿßÿØŸÖ€åŸÜ
building.action('submit_building', async (ctx) => {
    ctx.session ??= {};
    ctx.session.buildingUsedToday = true;
    ctx.session.lastBuildDate = new Date().toDateString();
    ctx.session.buildingRequestTime = Date.now();

    const userId = BigInt(ctx.from.id);
    const country = ctx.user?.countryName;
    const {
        buildingType,
        buildingImageFileId,
        buildingDescription
    } = ctx.session;
    const buildingName = ctx.session.buildingType === 'car'
        ? ctx.session.carName
        : ctx.session.buildingName;

    if (!buildingType || !buildingName || !buildingImageFileId || !buildingDescription || !country) {
        return ctx.reply('‚ùå ÿßÿ∑ŸÑÿßÿπÿßÿ™ ŸÜÿßŸÇÿµ ÿßÿ≥ÿ™.');
    }

    const imageUrl = await ctx.telegram.getFileLink(buildingImageFileId).then(link => link.href);

    let setupCost: number;
    let profitPercent: number | null = null;

    if (buildingType === 'car') {
        setupCost = 250_000_000;
    } else {
        setupCost = Math.floor(55_000_000 + Math.random() * 695_000_000);
        profitPercent = Math.floor(10 + Math.random() * 72);
    }

    const result = await changeCapital(userId, 'subtract', setupCost);
    if (result !== 'ok') return ctx.reply('‚ùå ÿÆÿ∑ÿß ÿØÿ± ⁄©ÿ≥ÿ± ÿ≥ÿ±ŸÖÿß€åŸá.');

    await prisma.pendingProductionLine.create({
        data: {
            ownerId: userId,
            name: buildingName,
            type: buildingType,
            imageUrl,
            imageFileId: buildingImageFileId,
            description: buildingDescription,
            dailyLimit: 15,
            setupCost: BigInt(setupCost),
            country,
            profitPercent
        }
    });

    const caption = escapeMarkdownV2(
        `üì• ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ≥ÿßÿÆÿ™ ${buildingType === 'car' ? 'ÿÆÿ∑ ÿ™ŸàŸÑ€åÿØ ÿÆŸàÿØÿ±Ÿà' : `Ÿæÿ±Ÿà⁄òŸá ${buildingType}`}\n\n` +
        `> ⁄©ÿ¥Ÿàÿ±: **${country}**\n` +
        `> ŸÜÿßŸÖ: **${buildingName}**\n` +
        `> ÿ™Ÿàÿ∂€åÿ≠: ${buildingDescription}\n` +
        `> ÿ®ŸàÿØÿ¨Ÿá: ${Math.floor(setupCost / 1_000_000)}M` +
        (profitPercent !== null ? `\n> ÿ≥ŸàÿØÿØŸá€å: ${profitPercent}%` : '') +
        (buildingType === 'car' ? `\nÿ∏ÿ±ŸÅ€åÿ™ ÿ™ŸàŸÑ€åÿØ ÿ±Ÿàÿ≤ÿßŸÜŸá: 15 ÿÆŸàÿØÿ±Ÿà` : '')
    );

    const adminKeyboard = Markup.inlineKeyboard([
        [Markup.button.callback('‚úÖ ÿ™ÿ£€å€åÿØ ÿ≥ÿßÿÆÿ™', `admin_approve_building_${userId}`)],
        [Markup.button.callback('‚ùå ÿ±ÿØ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™', `admin_reject_building_${userId}`)]
    ]);

    for (const admin of admins) {
        await ctx.telegram.sendPhoto(admin, buildingImageFileId, {
            caption,
            parse_mode: 'MarkdownV2',
            reply_markup: adminKeyboard.reply_markup
        });
    }

    await ctx.reply('üì§ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ¥ŸÖÿß ÿ®ÿ±ÿß€å ÿ®ÿ±ÿ±ÿ≥€å ÿßÿØŸÖ€åŸÜ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ.');
    ctx.session.buildingStep = undefined;
});
// ÿ™ÿ£€å€åÿØ ŸÜŸáÿß€å€å ÿ™Ÿàÿ≥ÿ∑ ÿßÿØŸÖ€åŸÜ
building.action(/admin_approve_building_(\d+)/, async (ctx) => {
    const userId = BigInt(ctx.match[1]);

    const user = await prisma.user.findUnique({ where: { userid: userId } });
    if (!user) return ctx.reply('‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.');

    const pending = await prisma.pendingProductionLine.findFirst({ where: { ownerId: userId } });
    if (!pending) return ctx.reply('‚ùå ÿßÿ∑ŸÑÿßÿπÿßÿ™ ŸÖÿ≠ÿµŸàŸÑ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.');

    if (['film', 'music', 'game'].includes(pending.type)) {
        await prisma.productionLine.create({
            data: {
                ownerId: userId,
                name: pending.name,
                type: pending.type,
                imageUrl: pending.imageUrl,
                dailyLimit: pending.dailyLimit,
                setupCost: pending.setupCost,
                country: pending.country,
                profitPercent: pending.profitPercent
            }
        });

        await prisma.pendingProductionLine.delete({ where: { id: pending.id } });

        await ctx.telegram.sendPhoto(config.channels.updates, pending.imageFileId, {
            caption: escapeMarkdownV2(
                `üè≠ ÿÆÿ∑ ÿ™ŸàŸÑ€åÿØ ÿ¨ÿØ€åÿØ ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ÿ¥ÿØ\n\n` +
                `> ⁄©ÿ¥Ÿàÿ± ÿ≥ÿßÿ≤ŸÜÿØŸá: **${user.countryName}**\n` +
                `> ŸÖÿ≠ÿµŸàŸÑ: **${pending.name}**\n\n` +
                `ÿ®ŸàÿØÿ¨Ÿá ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å: ${pending.setupCost.toLocaleString()} ÿ±€åÿßŸÑ\n` +
                `ÿ∏ÿ±ŸÅ€åÿ™ ÿ™ŸàŸÑ€åÿØ ÿ±Ÿàÿ≤ÿßŸÜŸá: ${pending.dailyLimit} Ÿàÿßÿ≠ÿØ`
            ),
            parse_mode: 'MarkdownV2'
        });


        await ctx.reply('‚úÖ Ÿæÿ±Ÿà⁄òŸá ÿ™ÿ£€å€åÿØ ÿ¥ÿØ Ÿà ÿ®Ÿá ⁄©ÿßŸÜÿßŸÑ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ.');
    }

    const result = await createProductionLine({
        ownerId: userId,
        country: pending.country,
        name: pending.name,
        type: pending.type,
        imageUrl: pending.imageUrl,
        dailyLimit: pending.dailyLimit,
        setupCost: pending.setupCost,
        carName: pending.name
    });

    if (result.error) return ctx.reply(result.error);

    await prisma.pendingProductionLine.deleteMany({ where: { ownerId: userId } });

    await ctx.telegram.sendPhoto(config.channels.updates, pending.imageFileId, {
        caption: escapeMarkdownV2(
            `üè≠ ÿÆÿ∑ ÿ™ŸàŸÑ€åÿØ ÿ¨ÿØ€åÿØ ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ÿ¥ÿØ\n\n` +
            `> ⁄©ÿ¥Ÿàÿ± ÿ≥ÿßÿ≤ŸÜÿØŸá: **${user.countryName}**\n` +
            `> ŸÖÿ≠ÿµŸàŸÑ: **${pending.name}**\n\n` +
            `ÿ®ŸàÿØÿ¨Ÿá ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å: ${pending.setupCost.toLocaleString()} ÿ±€åÿßŸÑ\n` +
            `ÿ∏ÿ±ŸÅ€åÿ™ ÿ™ŸàŸÑ€åÿØ ÿ±Ÿàÿ≤ÿßŸÜŸá: ${pending.dailyLimit} Ÿàÿßÿ≠ÿØ`
        ),
        parse_mode: 'MarkdownV2'
    });

    await ctx.reply('‚úÖ ÿÆÿ∑ ÿ™ŸàŸÑ€åÿØ ÿ´ÿ®ÿ™ ÿ¥ÿØ Ÿà ÿ®Ÿá ⁄©ÿßŸÜÿßŸÑ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ.');
});
// ÿ±ÿØ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ™Ÿàÿ≥ÿ∑ ÿßÿØŸÖ€åŸÜ
building.action(/admin_reject_building_(\d+)/, async (ctx) => {
    const userId = BigInt(ctx.match[1]);
    const adminId = ctx.from.id;

    if (!admins.includes(adminId)) {
        return ctx.answerCbQuery('‚õî ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ ŸÖ€å‚Äåÿ™ŸàŸÜŸá ÿ±ÿØ ⁄©ŸÜŸá.');
    }

    const pending = await prisma.pendingProductionLine.findFirst({ where: { ownerId: userId } });

    if (!pending) {
        return ctx.answerCbQuery('‚ùå ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.');
    }

    // ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜÿØŸÜ ŸæŸàŸÑ
    const result = await changeCapital(userId, 'add', Number(pending.setupCost));
    if (result === 'not_found') {
        return ctx.answerCbQuery('‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.');
    }
    if (result === 'invalid' || result === 'error') {
        return ctx.answerCbQuery('‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜÿØŸÜ ŸæŸàŸÑ.');
    }

    // ÿ≠ÿ∞ŸÅ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™
    await prisma.pendingProductionLine.deleteMany({ where: { ownerId: userId } });

    // ÿßÿ∑ŸÑÿßÿπ‚Äåÿ±ÿ≥ÿßŸÜ€å ÿ®Ÿá ⁄©ÿßÿ±ÿ®ÿ±
    try {
        await ctx.telegram.sendMessage(Number(userId),
            `‚ùå ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ≥ÿßÿÆÿ™ ÿÆÿ∑ ÿ™ŸàŸÑ€åÿØ ÿ¥ŸÖÿß ÿ±ÿØ ÿ¥ÿØ.\nüí∞ ŸÖÿ®ŸÑÿ∫ ${Number(pending.setupCost / BigInt(1_000_000)).toLocaleString()}M ÿ®Ÿá ÿ≠ÿ≥ÿßÿ® ÿ¥ŸÖÿß ÿ®ÿ±⁄Øÿ¥ÿ™.`
        );
    } catch (err) {
        console.warn('ÿßÿ±ÿ≥ÿßŸÑ Ÿæ€åÿßŸÖ ÿ®Ÿá PV ⁄©ÿßÿ±ÿ®ÿ± ŸÖŸÖ⁄©ŸÜ ŸÜÿ®ŸàÿØ:', err);
    }

    await ctx.answerCbQuery('‚úÖ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ±ÿØ ÿ¥ÿØ Ÿà ŸæŸàŸÑ ÿ®ÿ±⁄Øÿ¥ÿ™.');
});

for (const type of ['film', 'music', 'game']) {
    building.action(`build_${type}`, async (ctx) => {
        ctx.session = {
            buildingType: type,
            buildingStep: 'awaiting_name'
        };
        await ctx.reply(`üìå ŸÜÿßŸÖ Ÿæÿ±Ÿà⁄òŸá ${type === 'film' ? 'ŸÅ€åŸÑŸÖ' : type === 'music' ? 'ŸÖŸàÿ≤€å⁄©' : 'ÿ®ÿßÿ≤€å'} ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ:`);
        ctx.answerCbQuery();
    });
}



export default building;
