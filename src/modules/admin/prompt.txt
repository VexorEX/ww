import { Composer, Markup } from 'telegraf';
import type { CustomContext } from '../../middlewares/userAuth';
import { prisma } from '../../prisma';
import config from '../../config/config.json';
import fs from 'fs';
import path from 'path';
import { assetCategories , bigintFields } from '../../constants/assetCategories';

const adminPanel = new Composer<CustomContext>();
const CONFIG_PATH = path.join(__dirname, '../../config/config.json');
const REWARD_LOG_PATH = path.join(__dirname, '../../config/dailyRewardLog.json');
const ADMIN_IDS: number[] = config.manage.country.admins || [];

//
// âœ… Ù¾Ù†Ù„ Ø§ØµÙ„ÛŒ Ø¨Ø§ /panel
//
adminPanel.command('panel', async (ctx) => {
    if (!ADMIN_IDS.includes(ctx.from.id)) return ctx.reply('â›” Ø´Ù…Ø§ Ø§Ø¯Ù…ÛŒÙ† Ù†ÛŒØ³ØªÛŒØ¯.');

    const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('ğŸ›  ÙˆÛŒØ±Ø§ÛŒØ´ Ø¯Ø§Ø±Ø§ÛŒÛŒ', 'admin_edit_asset')],
        [Markup.button.callback('ğŸ§© Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ù†Ùˆ', 'admin_toggle_menu')],
        [Markup.button.callback('ğŸ Ø§Ø±Ø³Ø§Ù„ Ø¬Ø§ÛŒØ²Ù‡ Ø±ÙˆØ²Ø§Ù†Ù‡', 'admin_daily_reward')],
        [Markup.button.callback('âŒ Ø¨Ø³ØªÙ†', 'delete')]
    ]);

    await ctx.reply('ğŸ› Ù¾Ù†Ù„ Ù…Ø¯ÛŒØ±ÛŒØª:', keyboard);
});

adminPanel.action('admin_edit_asset', async (ctx) => {
    ctx.session ??= {};
    await ctx.reply('ğŸ“Œ Ù„Ø·ÙØ§Ù‹ Ø´Ù†Ø§Ø³Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†:\nÙ…Ø«Ø§Ù„: /editasset 123456789');
    ctx.answerCbQuery();
});

adminPanel.action('admin_toggle_menu', async (ctx) => {
    ctx.session ??= {};

    const sections = Object.entries(config.manage).filter(([_, val]) =>
        typeof val === 'object' && val !== null && 'status' in val
    );

    const keyboard = Markup.inlineKeyboard(
        sections.map(([key, val]) => {
            const status = (val as { status: boolean }).status;
            return [Markup.button.callback(`${status ? 'âœ…' : 'âŒ'} ${key}`, `toggle_section_${key}`)];
        })
    );


    await ctx.reply('ğŸ§© ÙˆØ¶Ø¹ÛŒØª Ù†Ù…Ø§ÛŒØ´ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ù†Ùˆ:', keyboard);
    ctx.answerCbQuery();
});

adminPanel.action(/^toggle_section_(\w+)$/, async (ctx) => {
    const section = ctx.match[1];
    const current = config.manage[section]?.status;

    if (typeof current !== 'boolean') return ctx.answerCbQuery('âŒ Ø¨Ø®Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.');
    config.manage[section].status = !current;
    fs.writeFileSync(CONFIG_PATH, JSON.stringify(config, null, 2), 'utf-8');

    await ctx.editMessageText(`âœ… ÙˆØ¶Ø¹ÛŒØª "${section}" Ø¨Ù‡ ${!current ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'} ØªØºÛŒÛŒØ± ÛŒØ§ÙØª.`);
    ctx.answerCbQuery();
});

adminPanel.action('admin_daily_reward', async (ctx) => {
    ctx.session ??= {};
    const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('ğŸ Ø§Ø±Ø³Ø§Ù„ Ø¬Ø§ÛŒØ²Ù‡ Ø±ÙˆØ²Ø§Ù†Ù‡', 'send_daily_reward')]
    ]);
    await ctx.reply('ğŸ¯ ÙÙ‚Ø· ÛŒÚ©â€ŒØ¨Ø§Ø± Ø¯Ø± Ø±ÙˆØ² Ù‚Ø§Ø¨Ù„ Ø§Ø¬Ø±Ø§Ø³Øª:', keyboard);
    ctx.answerCbQuery();
});

adminPanel.action('send_daily_reward', async (ctx) => {
    if (!ADMIN_IDS.includes(ctx.from.id)) return ctx.answerCbQuery('â›” Ø¯Ø³ØªØ±Ø³ÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯.');

    const today = new Date().toISOString().split('T')[0];
    let lastSent = '';

    try {
        const log = JSON.parse(fs.readFileSync(REWARD_LOG_PATH, 'utf-8'));
        lastSent = log.lastSent || '';
    } catch {
        lastSent = '';
    }

    if (lastSent === today) return ctx.answerCbQuery('â›” Ø¬Ø§ÛŒØ²Ù‡ Ø§Ù…Ø±ÙˆØ² Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡.');

    const users = await prisma.user.findMany();
    let count = 0;

    for (const user of users) {
        const profit = BigInt(user.dailyProfit || 0);
        const current = BigInt(user.capital || 0);
        await prisma.user.update({
            where: { userid: user.userid },
            data: { capital: current + profit }
        });
        count++;
    }

    fs.writeFileSync(REWARD_LOG_PATH, JSON.stringify({ lastSent: today }, null, 2), 'utf-8');
    await ctx.reply(`âœ… Ø¬Ø§ÛŒØ²Ù‡ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø¨Ø±Ø§ÛŒ ${count} Ú©Ø§Ø±Ø¨Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.`);
    ctx.answerCbQuery('ğŸ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯!');
});

//
// âœ… ÙˆÛŒØ±Ø§ÛŒØ´ Ø¯Ø§Ø±Ø§ÛŒÛŒ Ø¨Ø§ /editasset
//
adminPanel.command('editasset', async (ctx) => {
    if (!ADMIN_IDS.includes(ctx.from.id)) return ctx.reply('â›” Ø¯Ø³ØªØ±Ø³ÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯.');
    const args = ctx.message.text.split(' ');
    const userIdStr = args[1];
    if (!userIdStr || !/^\d+$/.test(userIdStr)) return ctx.reply('âŒ ÙØ±Ù…Øª ØµØ­ÛŒØ­ Ù†ÛŒØ³Øª. Ù…Ø«Ø§Ù„: /editasset 123456789');

    ctx.session ??= {};
    ctx.session.editUserId = BigInt(userIdStr);

    const keyboard = Markup.inlineKeyboard(
        Object.keys(assetCategories).map((cat) => [Markup.button.callback(cat, `edit_cat_${cat}`)])
    );

    await ctx.reply('ğŸ”§ Ø¯Ø³ØªÙ‡ Ø¯Ø§Ø±Ø§ÛŒÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:', keyboard);
});

adminPanel.action(/^edit_cat_(\w+)$/, async (ctx) => {
    ctx.session ??= {};
    const category = ctx.match[1];
    const items = assetCategories[category];
    if (!items) return ctx.answerCbQuery('âŒ Ø¯Ø³ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.');

    ctx.session.editCategory = category;

    const keyboard = Markup.inlineKeyboard(
        items.map((item) => [Markup.button.callback(item, `edit_item_${item}`)])
    );

    await ctx.editMessageText(`ğŸ” Ù…ÙˆØ±Ø¯ÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒ ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ù†ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:`, keyboard);
    ctx.answerCbQuery();
});

adminPanel.action(/^edit_item_(\w+)$/, async (ctx) => {
    ctx.session ??= {};
    ctx.session.editItem = ctx.match[1];
    ctx.session.editStep = 'awaiting_value';
    await ctx.reply('âœï¸ Ù…Ù‚Ø¯Ø§Ø± Ø¬Ø¯ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†:\n+25 Ø¨Ø±Ø§ÛŒ Ø§ÙØ²Ø§ÛŒØ´ØŒ -25 Ø¨Ø±Ø§ÛŒ Ú©Ø§Ù‡Ø´ØŒ 25 Ø¨Ø±Ø§ÛŒ Ù…Ù‚Ø¯Ø§Ø± Ù…Ø³ØªÙ‚ÛŒÙ…');
    ctx.answerCbQuery();
});

adminPanel.on('text', async (ctx, next) => {
    ctx.session ??= {};
    if (ctx.session.editStep !== 'awaiting_value') return next();

    const valueStr = ctx.message.text.trim();
    const value = Number(valueStr);
    if (isNaN(value)) return ctx.reply('âŒ Ù…Ù‚Ø¯Ø§Ø± Ø¹Ø¯Ø¯ÛŒ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.');

    const { editUserId, editItem } = ctx.session;
    const user = await prisma.user.findUnique({ where: { userid: editUserId } });
    if (!user) return ctx.reply('âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯.');

    const isBigInt = ['capital', 'dailyProfit', 'crowd'].includes(editItem);

    let newValue: number | bigint;

    if (isBigInt) {
        const current = BigInt(user[editItem] || 0);
        if (valueStr.startsWith('+')) {
            newValue = current + BigInt(value);
        } else if (valueStr.startsWith('-')) {
            newValue = current - BigInt(Math.abs(value));
        } else {
            newValue = BigInt(value);
        }
    } else {
        const current = Number(user[editItem] || 0);
        if (valueStr.startsWith('+')) {
            newValue = current + value;
        } else if (valueStr.startsWith('-')) {
            newValue = current - Math.abs(value);
        } else {
            newValue = value;
        }
    }

    await prisma.user.update({
        where: { userid: editUserId },
        data: { [editItem]: isBigInt ? newValue : Number(newValue) }
    });

    await ctx.reply(`âœ… Ù…Ù‚Ø¯Ø§Ø± Ø¬Ø¯ÛŒØ¯ ${editItem} Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± ${editUserId} ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯: ${newValue.toLocaleString()}`);
    ctx.session.editStep = undefined;
});

export default adminPanel;



 in hanozam az command estefade mikone o man nmikham injori bashe behtare ke in bakhsh ro be shekl ghesmat management besazim (agar lazeme oon ro ham alan mifrestam
 import { Composer, Markup } from 'telegraf';
 import { CustomContext } from '../middlewares/userAuth';
 import { getCountryData } from '../utils/displayCountry';
 import {escapeMarkdownV2} from '../utils/escape';
 import countries from '../config/countries.json';
 import more from '../config/more.json';
 import config from '../config/config.json';
 import { prisma } from '../prisma';

 const countryManagement = new Composer<CustomContext>();

 function getContinentEmoji(countryCode: string): string {
     for (const [continent, list] of Object.entries(countries)) {
         if (countryCode in list) {
             switch (continent) {
                 case 'america': return 'ğŸŒ Ø¢Ù…Ø±ÛŒÚ©Ø§';
                 case 'asia': return 'ğŸŒ Ø¢Ø³ÛŒØ§';
                 case 'europe': return 'ğŸŒ Ø§Ø±ÙˆÙ¾Ø§';
                 case 'africa': return 'ğŸŒ Ø¢ÙØ±ÛŒÙ‚Ø§';
                 case 'australia': return 'ğŸŒ Ø§Ù‚ÛŒØ§Ù†ÙˆØ³ÛŒÙ‡';
                 default: return 'ğŸŒ Ù†Ø§Ù…Ø´Ø®Øµ';
             }
         }
     }
     return 'ğŸŒ Ù†Ø§Ù…Ø´Ø®Øµ';
 }
 function formatNumber(input: string | number): string {
     const num = typeof input === 'string' ? parseInt(input.replace(/,/g, ''), 10) : input;
     if (num >= 1_000_000_000) return (num / 1_000_000_000).toFixed(1) + 'B';
     if (num >= 1_000_000) return (num / 1_000_000).toFixed(1) + 'M';
     if (num >= 1_000) return (num / 1_000).toFixed(1) + 'K';
     return num.toString();
 }
 function getRankLabel(rank: number): string {
     return more.ranks[`rank${rank}`] || `Ø±ØªØ¨Ù‡ ${rank}`;
 }

 function getReligionLabel(key: string): string {
     return more.religion[key] || key;
 }
 function buildCountryInlineKeyboard(user: any): Markup.Markup<any> {
     return Markup.inlineKeyboard([
         [
             Markup.button.callback(`${user.countryName}`, 'NA'),
             Markup.button.callback(`${more.governments[user.government] || user.government}`, 'set_gov'),
             Markup.button.callback(`${getReligionLabel(user.religion)}`, 'set_religion')
         ],
         [
             Markup.button.callback(getContinentEmoji(user.country), 'NA'),
             Markup.button.callback(`ğŸ– ${getRankLabel(user.rank)}`, 'NA')
         ],
         [Markup.button.callback('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'NA')],
         [
             Markup.button.callback('ğŸ‘¥ Ø¬Ù…Ø¹ÛŒØª', 'NA'),
             Markup.button.callback('ğŸ’° Ø¯Ø±Ø¢Ù…Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡', 'NA'),
             Markup.button.callback('ğŸ¦ Ø³Ø±Ù…Ø§ÛŒÙ‡', 'NA')
         ],
         [
             Markup.button.callback(`ğŸ‘¥ ${formatNumber(user.crowd)}`, 'NA'),
             Markup.button.callback(`ğŸ’° ${formatNumber(user.dailyProfit)}`, 'NA'),
             Markup.button.callback(`ğŸ¦ ${formatNumber(user.capital)}`, 'NA')
         ],
         [
             Markup.button.callback('ğŸ›¡ Ø§Ù…Ù†ÛŒØª', 'NA'),
             Markup.button.callback('ğŸ˜Š Ø±Ø¶Ø§ÛŒØª', 'NA')
         ],
         [
             Markup.button.callback(`ğŸ›¡ ${user.security}`, 'NA'),
             Markup.button.callback(`ğŸ˜Š ${user.satisfaction}`, 'NA')
         ],
         [Markup.button.callback('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'NA')],
         [
             Markup.button.callback('ğŸª¨ Ù…Ù†Ø§Ø¨Ø¹', 'get_resources'),
             Markup.button.callback('âš”ï¸ Ù†Ø¸Ø§Ù…ÛŒ', 'get_armies')
         ],
         [Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'back_main')]
     ]);
 }

 function buildReligionUpdateMessage(countryName: string, oldRel: string, newRel: string): string {
     return `${countryName} Ø¨Ù‡ Ø·ÙˆØ± Ø±Ø³Ù…ÛŒ Ø¯ÛŒÙ† Ø±Ø³Ù…ÛŒ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯! ğŸ•Š

 > Ø¯ÛŒÙ† Ù‚Ø¨Ù„ÛŒ: ${oldRel || 'Ù†Ø§Ù…Ø´Ø®Øµ'}
 > Ø¯ÛŒÙ† Ø¬Ø¯ÛŒØ¯: ${newRel}

 Ø´Ø±Ø­: Ú©Ø´ÙˆØ± ${countryName} Ø·ÛŒ Ø±ÙˆØ²Ù‡Ø§ÛŒ Ø§Ø®ÛŒØ± Ø¯ÛŒÙ† Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ù‡ Ø·ÙˆØ± Ø±Ø³Ù…ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ùˆ Ø«Ø¨Øª Ú©Ø±Ø¯ ğŸ“`;
 }
 function buildGovUpdateMessage(countryName: string, oldGov: string, newGov: string): string {
     return `${countryName} Ø¨Ù‡ Ø·ÙˆØ± Ø±Ø³Ù…ÛŒ Ù†ÙˆØ¹ Ø­Ú©ÙˆÙ…Øª Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯! ğŸ‘¤

 > Ø­Ú©ÙˆÙ…Øª Ù‚Ø¨Ù„ÛŒ: ${oldGov || 'Ù†Ø§Ù…Ø´Ø®Øµ'}
 > Ø­Ú©ÙˆÙ…Øª Ø¬Ø¯ÛŒØ¯: ${newGov}

 Ø´Ø±Ø­: Ú©Ø´ÙˆØ± ${countryName} Ø·ÛŒ Ø±ÙˆØ²Ù‡Ø§ÛŒ Ø§Ø®ÛŒØ± Ù†ÙˆØ¹ Ø­Ú©ÙˆÙ…Øª Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ù‡ Ø·ÙˆØ± Ø±Ø³Ù…ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ùˆ Ø«Ø¨Øª Ú©Ø±Ø¯ Ø§ÛŒÙ† Ú©Ø§Ø± Ù…Ù…Ú©Ù† Ø§Ø³Øª ÙˆØ§Ú©Ù†Ø´â€ŒÙ‡Ø§ÛŒ Ù…Ø±Ø¯Ù…ÛŒ Ù…Ø«Ø¨Øª ÛŒØ§ Ù…Ù†ÙÛŒ Ø¨Ù‡ Ø¯Ù†Ø¨Ø§Ù„ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯ ğŸ›`;
 }

 async function sendUpdateToChannel(type: 'religion' | 'gov', message: string, ctx: CustomContext) {
     const imageUrl = config.images[type]; // Ø¨Ø§ÛŒØ¯ Ù„ÛŒÙ†Ú© Ù…Ø³ØªÙ‚ÛŒÙ… Ø¨Ø§Ø´Ù‡
     const caption = escapeMarkdownV2(message);

     if (imageUrl?.startsWith('http')) {
         await ctx.telegram.sendPhoto(config.channels.updates, imageUrl, {
             caption,
             parse_mode: 'MarkdownV2'
         });
     } else {
         await ctx.telegram.sendMessage(config.channels.updates, caption, {
             parse_mode: 'MarkdownV2'
         });
     }
 }
 countryManagement.action('management', async (ctx) => {
     const country = ctx.user?.country;
     if (!country) return ctx.reply('âŒ Ú©Ø´ÙˆØ± Ø´Ù…Ø§ Ù…Ø´Ø®Øµ Ù†ÛŒØ³Øª.');
     const result = await getCountryData(country);
     if (result.error || !result.user) return ctx.reply(result.error || 'âŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø´ÙˆØ± ÛŒØ§ÙØª Ù†Ø´Ø¯.');
     const keyboard = buildCountryInlineKeyboard(result.user);
     await ctx.reply(`ğŸ¯ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø´ÙˆØ± ${result.user.countryName}`, keyboard);
 });

 countryManagement.action('set_gov', async (ctx) => {
     if (!config.manage.management.governments.status) {
         await ctx.answerCbQuery('â›” ØªØºÛŒÛŒØ± Ø­Ú©ÙˆÙ…Øª Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª.');
         return;
     }

     const keyboard = Markup.inlineKeyboard(
         Object.entries(more.governments).map(([key, label]) => [
             Markup.button.callback(label, `change_gov_${key}`)
         ])
     );
     await ctx.editMessageText('ğŸ‘‘ Ù†ÙˆØ¹ Ø­Ú©ÙˆÙ…Øª Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:', keyboard);
     ctx.answerCbQuery();
 });
 countryManagement.action(/^change_gov_(\w+)$/, async (ctx) => {
     const newGov = ctx.match[1];
     const user = await prisma.user.findUnique({ where: { userid: BigInt(ctx.from.id) } });
     const oldGov = user?.government || 'Ù†Ø§Ù…Ø´Ø®Øµ';
     const countryName = user?.countryName || 'Ú©Ø´ÙˆØ± Ø´Ù…Ø§';

     await prisma.user.update({
         where: { userid: BigInt(ctx.from.id) },
         data: { government: newGov }
     });

     await ctx.editMessageText(`âœ… Ø­Ú©ÙˆÙ…Øª Ø´Ù…Ø§ Ø¨Ù‡ ${more.governments[newGov]} ØªØºÛŒÛŒØ± ÛŒØ§ÙØª.`);
     ctx.answerCbQuery();

     const message = buildGovUpdateMessage(countryName, more.governments[oldGov] || oldGov, more.governments[newGov]);
     try {
         await sendUpdateToChannel('gov', message, ctx);
     } catch (err) {
         console.error('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ú©Ø§Ù†Ø§Ù„:', err);
     }
 });

 countryManagement.action('set_religion', async (ctx) => {
     if (!config.manage.management.religion.status) {
         await ctx.answerCbQuery('â›” ØªØºÛŒÛŒØ± Ø¯ÛŒÙ† Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª.');
         return;
     }

     const keyboard = Markup.inlineKeyboard(
         Object.entries(more.religion).map(([key, label]) => [
             Markup.button.callback(label, `change_religion_${key}`)
         ])
     );
     await ctx.editMessageText('ğŸ•Œ Ø¯ÛŒÙ† Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:', keyboard);
     ctx.answerCbQuery();
 });
 countryManagement.action(/^change_religion_(\w+)$/, async (ctx) => {
     const newRel = ctx.match[1];
     const user = await prisma.user.findUnique({ where: { userid: BigInt(ctx.from.id) } });
     const oldRel = user?.religion || 'Ù†Ø§Ù…Ø´Ø®Øµ';
     const countryName = user?.countryName || 'Ú©Ø´ÙˆØ± Ø´Ù…Ø§';

     await prisma.user.update({
         where: { userid: BigInt(ctx.from.id) },
         data: { religion: newRel }
     });

     await ctx.editMessageText(`âœ… Ø¯ÛŒÙ† Ø´Ù…Ø§ Ø¨Ù‡ ${more.religion[newRel]} ØªØºÛŒÛŒØ± ÛŒØ§ÙØª.`);
     ctx.answerCbQuery();

     const message = buildReligionUpdateMessage(countryName, more.religion[oldRel] || oldRel, more.religion[newRel]);
     try {
         await sendUpdateToChannel('religion', message, ctx);
     } catch (err) {
         console.error('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ú©Ø§Ù†Ø§Ù„:', err);
     }
 });

 const armyCategories = [
     { name: 'ğŸŒ Ù†ÛŒØ±ÙˆÙ‡Ø§ÛŒ Ø²Ù…ÛŒÙ†ÛŒ', callback: 'army_ground' },
     { name: 'ğŸ›¡ Ø³Ø§Ù…Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯ÙØ§Ø¹ÛŒ', callback: 'army_defence' },
     { name: 'ğŸŒŠ Ù†ÛŒØ±ÙˆÙ‡Ø§ÛŒ Ø¯Ø±ÛŒØ§ÛŒÛŒ', callback: 'army_marine' },
     { name: 'âœˆï¸ Ù†ÛŒØ±ÙˆÙ‡Ø§ÛŒ Ù‡ÙˆØ§ÛŒÛŒ', callback: 'army_aerial' },
 ];
 const armyActions = [
     { name: 'ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', callback: 'back_main' },
     { name: 'âŒ Ø¨Ø³ØªÙ†', callback: 'delete' },
 ];
 const keyboardArm = Markup.inlineKeyboard([
     [Markup.button.callback(armyCategories[0].name, armyCategories[0].callback),
         Markup.button.callback(armyCategories[1].name, armyCategories[1].callback)],
     [Markup.button.callback(armyCategories[2].name, armyCategories[2].callback),
         Markup.button.callback(armyCategories[3].name, armyCategories[3].callback)],
     armyActions.map(a => Markup.button.callback(a.name, a.callback))
 ]);
 countryManagement.action('get_armies', async (ctx) => {
     await ctx.reply('âš”ï¸ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù†ÛŒØ±ÙˆÙ‡Ø§ÛŒ Ù†Ø¸Ø§Ù…ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:', keyboardArm);
     ctx.answerCbQuery();
 });

 const resourceCategories = [
     { name: 'ğŸ“¦ Ù…Ù†Ø§Ø¨Ø¹ Ù¾Ø§ÛŒÙ‡', callback: 'res_base' },
     { name: 'ğŸ— ØªØ¬Ù‡ÛŒØ²Ø§Øª Ø§Ø³ØªØ®Ø±Ø§Ø¬', callback: 'res_mines' },
 ];
 const resourceActions = [
     { name: 'ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', callback: 'back_main' },
     { name: 'âŒ Ø¨Ø³ØªÙ†', callback: 'delete' },
 ];
 const keyboardRes = Markup.inlineKeyboard([
     [Markup.button.callback(resourceCategories[0].name, resourceCategories[0].callback),
         Markup.button.callback(resourceCategories[1].name, resourceCategories[1].callback)],
     resourceActions.map(a => Markup.button.callback(a.name, a.callback))
 ]);
 countryManagement.action('get_resources', async (ctx) => {
     await ctx.reply('ğŸ“Š Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù…Ù†Ø§Ø¨Ø¹ Ú©Ø´ÙˆØ± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:', keyboardRes);
     ctx.answerCbQuery();
 });
 countryManagement.action('res_base', async (ctx) => {
     const country = ctx.user?.country;
     const result = await getCountryData(country);
     if (result.error || !result.user) return ctx.reply(result.error || 'âŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø´ÙˆØ± ÛŒØ§ÙØª Ù†Ø´Ø¯.');
     const u = result.user;

     const keyboard = Markup.inlineKeyboard([
         buildRow('ğŸ”© Ø¢Ù‡Ù†', u.iron),
         buildRow('ğŸ’° Ø·Ù„Ø§', u.gold),
         buildRow('â˜¢ Ø§ÙˆØ±Ø§Ù†ÛŒÙˆÙ…', u.uranium),
         buildRow('ğŸ›¢ Ù†ÙØª', u.oil),
         [Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'get_resources')]
     ]);

     await ctx.reply('ğŸ“¦ Ù…Ù†Ø§Ø¨Ø¹ Ù¾Ø§ÛŒÙ‡ Ú©Ø´ÙˆØ± Ø´Ù…Ø§:', keyboard);
     ctx.answerCbQuery();
 });
 countryManagement.action('res_mines', async (ctx) => {
     const country = ctx.user?.country;
     const result = await getCountryData(country);
     if (result.error || !result.user) return ctx.reply(result.error || 'âŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø´ÙˆØ± ÛŒØ§ÙØª Ù†Ø´Ø¯.');
     const u = result.user;

     const keyboard = Markup.inlineKeyboard([
         buildRow('â› Ù…Ø¹Ø¯Ù† Ø¢Ù‡Ù†', u.ironMine),
         buildRow('ğŸ† Ù…Ø¹Ø¯Ù† Ø·Ù„Ø§', u.goldMine),
         buildRow('âš› Ù…Ø¹Ø¯Ù† Ø§ÙˆØ±Ø§Ù†ÛŒÙˆÙ…', u.uraniumMine),
         buildRow('ğŸ­ Ù¾Ø§Ù„Ø§ÛŒØ´Ú¯Ø§Ù‡ Ù†ÙØª', u.refinery),
         [Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'get_resources')]
     ]);

     await ctx.reply('ğŸ— ØªØ¬Ù‡ÛŒØ²Ø§Øª Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ú©Ø´ÙˆØ± Ø´Ù…Ø§:', keyboard);
     ctx.answerCbQuery();
 });

 function buildRow(label: string, value: string | number) {
     return [Markup.button.callback(label, 'NA'), Markup.button.callback(`${value}`, 'NA')];
 }

 countryManagement.action('get_armies', async (ctx) => {
     const keyboard = Markup.inlineKeyboard([
         [Markup.button.callback('ğŸŒ Ø²Ù…ÛŒÙ†ÛŒ', 'army_ground')],
         [Markup.button.callback('ğŸŒŠ Ø¯Ø±ÛŒØ§ÛŒÛŒ', 'army_marine')],
         [Markup.button.callback('âœˆï¸ Ù‡ÙˆØ§ÛŒÛŒ', 'army_aerial')],
         [Markup.button.callback('ğŸ›¡ Ø¯ÙØ§Ø¹ÛŒ', 'army_defence')],
         [Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'back_main')]
     ]);
     await ctx.reply('âš”ï¸ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù†ÛŒØ±ÙˆÙ‡Ø§ÛŒ Ù†Ø¸Ø§Ù…ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:', keyboard);
     ctx.answerCbQuery();
 });
 countryManagement.action('army_ground', async (ctx) => {
     const country = ctx.user?.country;
     const result = await getCountryData(country);
     if (result.error || !result.user) return ctx.reply(result.error || 'âŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø´ÙˆØ± ÛŒØ§ÙØª Ù†Ø´Ø¯.');
     const u = result.user;

     const keyboard = Markup.inlineKeyboard([
         buildRow('ğŸ‘¨â€âœˆï¸ Ù¾ÛŒØ§Ø¯Ù‡â€ŒÙ†Ø¸Ø§Ù…', u.soldier),
         buildRow('ğŸ›¡ ØªØ§Ù†Ú© Ø³Ø¨Ú©', u.tank),
         buildRow('ğŸ§± ØªØ§Ù†Ú© Ø³Ù†Ú¯ÛŒÙ†', u.heavyTank),
         [Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'get_armies')]
     ]);
     await ctx.reply('ğŸŒ Ù†ÛŒØ±ÙˆÙ‡Ø§ÛŒ Ø²Ù…ÛŒÙ†ÛŒ Ú©Ø´ÙˆØ± Ø´Ù…Ø§:', keyboard);
     ctx.answerCbQuery();
 });
 countryManagement.action('army_marine', async (ctx) => {
     const country = ctx.user?.country;
     const result = await getCountryData(country);
     if (result.error || !result.user) return ctx.reply(result.error || 'âŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø´ÙˆØ± ÛŒØ§ÙØª Ù†Ø´Ø¯.');
     const u = result.user;

     const keyboard = Markup.inlineKeyboard([
         buildRow('ğŸš¢ Ù†Ø¨Ø±Ø¯Ù†Ø§Ùˆ', u.battleship),
         buildRow('ğŸ›³ Ú©Ø´ØªÛŒ Ø¯Ø±ÛŒØ§ÛŒÛŒ', u.marineShip),
         buildRow('âš“ï¸ Ø´Ú©Ù†Ù†Ø¯Ù‡ Ø¯Ø±ÛŒØ§ÛŒÛŒ', u.breakerShip),
         buildRow('â˜¢ Ø²ÛŒØ±Ø¯Ø±ÛŒØ§ÛŒÛŒ Ù‡Ø³ØªÙ‡â€ŒØ§ÛŒ', u.nuclearSubmarine),
         [Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'get_armies')]
     ]);
     await ctx.reply('ğŸŒŠ Ù†ÛŒØ±ÙˆÙ‡Ø§ÛŒ Ø¯Ø±ÛŒØ§ÛŒÛŒ Ú©Ø´ÙˆØ± Ø´Ù…Ø§:', keyboard);
     ctx.answerCbQuery();
 });
 countryManagement.action('army_aerial', async (ctx) => {
     const country = ctx.user?.country;
     const result = await getCountryData(country);
     if (result.error || !result.user) return ctx.reply(result.error || 'âŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø´ÙˆØ± ÛŒØ§ÙØª Ù†Ø´Ø¯.');
     const u = result.user;

     const keyboard = Markup.inlineKeyboard([
         buildRow('âœˆï¸ F-16', u.f16),
         buildRow('âœˆï¸ F-22', u.f22),
         buildRow('âœˆï¸ F-35', u.f35),
         buildRow('âœˆï¸ J-20', u.j20),
         buildRow('âœˆï¸ SU-57', u.su57),
         buildRow('âœˆï¸ B-2', u.b2),
         buildRow('ğŸ›© Ù¾Ù‡Ù¾Ø§Ø¯ Ø¬Ø§Ø³ÙˆØ³ÛŒ', u.espionageDrone),
         buildRow('ğŸ›© Ù¾Ù‡Ù¾Ø§Ø¯ Ø§Ù†ØªØ­Ø§Ø±ÛŒ', u.suicideDrone),
         buildRow('ğŸ›© Ù¾Ù‡Ù¾Ø§Ø¯ Ø¹Ø¨ÙˆØ±ÛŒ', u.crossDrone),
         buildRow('ğŸ›© Ù¾Ù‡Ù¾Ø§Ø¯ Ø´Ø§Ù‡Ø¯', u.witnessDrone),
         buildRow('ğŸš€ Ù…ÙˆØ´Ú© Ø³Ø§Ø¯Ù‡', u.simpleRocket),
         buildRow('ğŸš€ Ù…ÙˆØ´Ú© Ù†Ù‚Ø·Ù‡â€ŒØ²Ù†', u.dotTargetRocket),
         buildRow('ğŸš€ Ù…ÙˆØ´Ú© Ù‚Ø§Ø±Ù‡â€ŒÙ¾ÛŒÙ…Ø§', u.continentalRocket),
         buildRow('ğŸš€ Ù…ÙˆØ´Ú© Ø¨Ø§Ù„Ø³ØªÛŒÚ©', u.ballisticRocket),
         buildRow('ğŸš€ Ù…ÙˆØ´Ú© Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ', u.chemicalRocket),
         buildRow('ğŸš€ Ù…ÙˆØ´Ú© Ù‡Ø§ÛŒÙ¾Ø±Ø³ÙˆÙ†ÛŒÚ©', u.hyperSonicRocket),
         buildRow('ğŸš€ Ù…ÙˆØ´Ú© Ø®ÙˆØ´Ù‡â€ŒØ§ÛŒ', u.clusterRocket),
         [Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'get_armies')]
     ]);
     await ctx.reply('âœˆï¸ Ù†ÛŒØ±ÙˆÙ‡Ø§ÛŒ Ù‡ÙˆØ§ÛŒÛŒ Ú©Ø´ÙˆØ± Ø´Ù…Ø§:', keyboard);
     ctx.answerCbQuery();
 });
 countryManagement.action('army_defence', async (ctx) => {
     const country = ctx.user?.country;
     const result = await getCountryData(country);
     if (result.error || !result.user) return ctx.reply(result.error || 'âŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø´ÙˆØ± ÛŒØ§ÙØª Ù†Ø´Ø¯.');
     const u = result.user;

     const keyboard = Markup.inlineKeyboard([
         buildRow('ğŸ›¡ Ø¶Ø¯ Ù…ÙˆØ´Ú©', u.antiRocket),
         buildRow('ğŸ›¡ Ú¯Ù†Ø¨Ø¯ Ø¢Ù‡Ù†ÛŒÙ†', u.ironDome),
         buildRow('ğŸ›¡ S-400', u.s400),
         buildRow('ğŸ›¡ TAAD', u.taad),
         buildRow('ğŸ›¡ HQ-9', u.hq9),
         buildRow('ğŸ›¡ Ø¢Ú©Ø§Ø´', u.acash),
         [Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'get_armies')]
     ]);
     await ctx.reply('ğŸ›¡ Ø³Ø§Ù…Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯ÙØ§Ø¹ÛŒ Ú©Ø´ÙˆØ± Ø´Ù…Ø§:', keyboard);
     ctx.answerCbQuery();
 });

 export default countryManagement;