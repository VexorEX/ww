import { Composer, Markup } from 'telegraf';
import type { CustomContext } from '../../middlewares/userAuth';
import { escapeMarkdownV2 } from '../../utils/escape';
import { prisma } from '../../prisma';
import config from '../../config/config.json';
import { changeCapital } from '../economy';

const admins: number[] = config.manage.buildings.construction.admins;
const construction = new Composer<CustomContext>();

type ProjectType = 'game' | 'film' | 'music';

const emojiMap: Record<ProjectType, string> = {
    game: 'ğŸ®',
    film: 'ğŸ¬',
    music: 'ğŸ¼'
};

// Ù…Ù†ÙˆÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†ÙˆØ¹ Ù¾Ø±ÙˆÚ˜Ù‡ Ø¹Ù…Ø±Ø§Ù†ÛŒ
construction.action('construction', async (ctx) => {
    const userId = BigInt(ctx.from.id);
    const user = await prisma.user.findUnique({ where: { userid: userId } });
    if (!user) return ctx.reply('âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯.');

    const today = new Date().toDateString();
    const last = user.lastConstructionBuildAt;
    const isSameDay = last && new Date(last).toDateString() === today;

    if (isSameDay) {
        return ctx.reply('â›” Ø§Ù…Ø±ÙˆØ² Ù‚Ø¨Ù„Ø§Ù‹ ÛŒÚ© Ù¾Ø±ÙˆÚ˜Ù‡ Ø³Ø§Ø®ØªÙ‡â€ŒØ§ÛŒØ¯. ÙØ±Ø¯Ø§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.');
    }

    const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('ğŸ® Ø¨Ø§Ø²ÛŒâ€ŒØ³Ø§Ø²ÛŒ', 'construct_game')],
        [Markup.button.callback('ğŸ¬ ÙÛŒÙ„Ù…â€ŒØ³Ø§Ø²ÛŒ', 'construct_film')],
        [Markup.button.callback('ğŸ¼ Ù…ÙˆØ²ÛŒÚ©â€ŒØ³Ø§Ø²ÛŒ', 'construct_music')],
        [Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'back_main')]
    ]);
    await ctx.reply('ğŸ— Ù†ÙˆØ¹ Ù¾Ø±ÙˆÚ˜Ù‡ Ø¹Ù…Ø±Ø§Ù†ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:', keyboard);
    ctx.answerCbQuery();
});

// Ø´Ø±ÙˆØ¹ Ø³Ø§Ø®Øª Ù¾Ø±ÙˆÚ˜Ù‡ Ø¹Ù…Ø±Ø§Ù†ÛŒ
for (const type of ['game', 'film', 'music'] as ProjectType[]) {
    construction.action(`construct_${type}`, async (ctx) => {
        ctx.session = {
            buildingType: type,
            buildingStep: 'awaiting_setup_cost'
        };
        await ctx.reply('ğŸ’° Ø³Ø±Ù…Ø§ÛŒÙ‡ Ø§ÙˆÙ„ÛŒÙ‡ Ù¾Ø±ÙˆÚ˜Ù‡ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù† (Ø¨ÛŒÙ† 55 ØªØ§ 750 Ù…ÛŒÙ„ÛŒÙˆÙ†):');
        ctx.answerCbQuery();
    });
}

// Ø¯Ø±ÛŒØ§ÙØª Ù…Ø±Ø§Ø­Ù„ Ù¾Ø±ÙˆÚ˜Ù‡ Ø¹Ù…Ø±Ø§Ù†ÛŒ
construction.on('text', async (ctx, next) => {
    ctx.session ??= {};

    if (ctx.session.buildingStep === 'awaiting_setup_cost') {
        const raw = ctx.message.text?.trim();
        const cost = Number(raw.replace(/[^\d]/g, ''));
        if (isNaN(cost) || cost < 55_000_000 || cost > 750_000_000) {
            return ctx.reply('âŒ Ø¹Ø¯Ø¯ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§Ù‹ Ø¹Ø¯Ø¯ÛŒ Ø¨ÛŒÙ† 55 ØªØ§ 750 Ù…ÛŒÙ„ÛŒÙˆÙ† ÙˆØ§Ø±Ø¯ Ú©Ù†.');
        }

        const userId = BigInt(ctx.from.id);
        const user = await prisma.user.findUnique({ where: { userid: userId } });
        if (!user) return ctx.reply('âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯.');
        if (user.capital < BigInt(cost)) {
            return ctx.reply(
                `âŒ Ø¨ÙˆØ¯Ø¬Ù‡ Ú©Ø§ÙÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯!\n` +
                `ğŸ’° Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²: ${(cost / 1_000_000).toLocaleString()}M\n` +
                `ğŸ’³ Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙØ¹Ù„ÛŒ: ${Number(user.capital / BigInt(1_000_000)).toLocaleString()}M`
            );
        }

        ctx.session.setupCost = cost;
        ctx.session.buildingStep = 'awaiting_name';
        await ctx.reply('ğŸ“Œ Ù†Ø§Ù… Ù¾Ø±ÙˆÚ˜Ù‡ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†:');
        return;
    }

    if (ctx.session.buildingStep === 'awaiting_name') {
        const name = ctx.message.text?.trim();
        if (!name || name.length < 2) return ctx.reply('âŒ Ù†Ø§Ù… Ù…Ø­ØµÙˆÙ„ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.');

        ctx.session.buildingName = name;
        ctx.session.buildingStep = 'awaiting_image';
        await ctx.reply('ğŸ–¼ Ø­Ø§Ù„Ø§ ØªØµÙˆÛŒØ± Ù…Ø­ØµÙˆÙ„ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†:');
        return;
    }

    return next();
});

// Ø¯Ø±ÛŒØ§ÙØª ØªØµÙˆÛŒØ± Ùˆ Ø§Ø±Ø³Ø§Ù„ Ø¨Ø±Ø§ÛŒ ØªØ£ÛŒÛŒØ¯ Ø§Ø¯Ù…ÛŒÙ†
construction.on('photo', async (ctx, next) => {
    ctx.session ??= {};
    if (ctx.session.buildingStep !== 'awaiting_image') return next();

    const photo = ctx.message.photo?.at(-1);
    if (!photo) return ctx.reply('âŒ ØªØµÙˆÛŒØ± Ù…Ø¹ØªØ¨Ø± Ø§Ø±Ø³Ø§Ù„ Ù†Ø´Ø¯Ù‡.');

    const imageUrl = await ctx.telegram.getFileLink(photo.file_id);
    const { buildingType, buildingName, setupCost } = ctx.session;
    const userId = BigInt(ctx.from.id);
    const user = ctx.user;
    const country = user.countryName;

    const result = await changeCapital(userId, 'subtract', setupCost);
    if (result !== 'ok') return ctx.reply('âŒ Ø®Ø·Ø§ Ø¯Ø± Ú©Ø³Ø± Ø³Ø±Ù…Ø§ÛŒÙ‡.');

    const profitPercent = Math.floor(10 + Math.random() * 72);
    const expiresAt = new Date(Date.now() + 3 * 60 * 60 * 1000); // 3 Ø³Ø§Ø¹Øª Ø¨Ø¹Ø¯

    const pending = await prisma.pendingProductionLine.create({
        data: {
            ownerId: userId,
            name: buildingName,
            type: buildingType,
            imageUrl: imageUrl.href,
            imageFileId: photo.file_id,
            description: '',
            dailyLimit: 0,
            setupCost: BigInt(setupCost),
            country,
            profitPercent,
            expiresAt
        }
    });

    const emoji = emojiMap[buildingType];
    const preview = escapeMarkdownV2(
        `${emoji} Ù¾Ø±ÙˆÚ˜Ù‡ Ø¬Ø¯ÛŒØ¯ Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯\n\n` +
        `Ú©Ø´ÙˆØ± Ø³Ø§Ø²Ù†Ø¯Ù‡: *${country}*\n` +
        `Ù…Ø­ØµÙˆÙ„: *${buildingName}*\n\n` +
        `Ø¨ÙˆØ¯Ø¬Ù‡ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ: ${setupCost.toLocaleString()} Ø±ÛŒØ§Ù„\n` +
        `Ø³ÙˆØ¯ Ø±ÙˆØ²Ø§Ù†Ù‡: ${profitPercent}% Ú©Ù„ Ø¨ÙˆØ¯Ø¬Ù‡`
    );

    const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('âœ… Ø§Ø±Ø³Ø§Ù„ Ø¨Ø±Ø§ÛŒ ØªØ£ÛŒÛŒØ¯ Ø§Ø¯Ù…ÛŒÙ†', `submit_construction_${pending.id}`)],
        [Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'construction')]
    ]);

    await ctx.replyWithPhoto(photo.file_id, {
        caption: preview,
        parse_mode: 'MarkdownV2',
        reply_markup: keyboard.reply_markup
    });

    ctx.session = {};
});

// Ø§Ø±Ø³Ø§Ù„ Ø¨Ø±Ø§ÛŒ ØªØ£ÛŒÛŒØ¯ Ø§Ø¯Ù…ÛŒÙ†
construction.action(/^submit_construction_(\d+)$/, async (ctx) => {
    const pendingId = Number(ctx.match[1]);
    const pending = await prisma.pendingProductionLine.findUnique({ where: { id: pendingId } });
    if (!pending) return ctx.reply('âŒ Ù¾Ø±ÙˆÚ˜Ù‡ ÛŒØ§ÙØª Ù†Ø´Ø¯.');

    const emoji = emojiMap[pending.type as ProjectType];
    const caption = escapeMarkdownV2(
        `${emoji} Ù¾Ø±ÙˆÚ˜Ù‡ Ø¬Ø¯ÛŒØ¯ Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯\n\n` +
        `Ú©Ø´ÙˆØ± Ø³Ø§Ø²Ù†Ø¯Ù‡: *${pending.country}*\n` +
        `Ù…Ø­ØµÙˆÙ„: *${pending.name}*\n\n` +
        `Ø¨ÙˆØ¯Ø¬Ù‡ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ: ${pending.setupCost.toLocaleString()} Ø±ÛŒØ§Ù„\n` +
        `Ø³ÙˆØ¯ Ø±ÙˆØ²Ø§Ù†Ù‡: ${pending.profitPercent}% Ú©Ù„ Ø¨ÙˆØ¯Ø¬Ù‡`
    );

    const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('âœ… ØªØ£ÛŒÛŒØ¯ Ø³Ø§Ø®Øª', `admin_approve_construction_${pendingId}`)],
        [Markup.button.callback('âŒ Ø±Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³Øª', `admin_reject_construction_${pendingId}`)]
    ]);

    for (const admin of admins) {
        const sent = await ctx.telegram.sendPhoto(admin, pending.imageFileId, {
            caption,
            parse_mode: 'MarkdownV2',
            reply_markup: keyboard.reply_markup
        });

        await prisma.pendingProductionLine.update({
            where: { id: pendingId },
            data: {
                adminMessageId: sent.message_id,
                adminChatId: BigInt(admin)
            }
        });
    }

    await ctx.reply('ğŸ“¤ Ù¾Ø±ÙˆÚ˜Ù‡ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.');
    ctx.answerCbQuery();
});

// ØªØ£ÛŒÛŒØ¯ ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ†
construction.action(/^admin_approve_construction_(\d+)$/, async (ctx) => {
    const adminId = ctx.from.id;
    if (!admins.includes(adminId)) {
        return ctx.answerCbQuery('â›” ÙÙ‚Ø· Ø§Ø¯Ù…ÛŒÙ† Ù…ÛŒâ€ŒØªÙˆÙ†Ù‡ ØªØ£ÛŒÛŒØ¯ Ú©Ù†Ù‡.');
    }

    const pendingId = Number(ctx.match[1]);
    const pending = await prisma.pendingProductionLine.findUnique({ where: { id: pendingId } });
    if (!pending) return ctx.reply('âŒ Ù¾Ø±ÙˆÚ˜Ù‡ ÛŒØ§ÙØª Ù†Ø´Ø¯.');
    const now = new Date();
    if (pending.expiresAt && pending.expiresAt < now) {
        return ctx.reply('â›” Ø§ÛŒÙ† Ù¾Ø±ÙˆÚ˜Ù‡ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ùˆ Ù‚Ø§Ø¨Ù„ ØªØ£ÛŒÛŒØ¯ Ù†ÛŒØ³Øª.');
    }

    const profitAmount = Math.floor(Number(pending.setupCost) * (pending.profitPercent ?? 0) / 100);

    await prisma.user.update({
        where: { userid: pending.ownerId },
        data: {
            dailyProfit: { increment: profitAmount },
            lastConstructionBuildAt: new Date()
        }
    });

    await prisma.productionLine.create({
        data: {
            ownerId: pending.ownerId,
            name: pending.name,
            type: pending.type,
            imageUrl: pending.imageUrl,
            imageFileId: pending.imageFileId,
            dailyLimit: 0,
            dailyOutput: 0,
            setupCost: pending.setupCost,
            country: pending.country,
            profitPercent: pending.profitPercent
        }
    });

    await prisma.pendingProductionLine.delete({ where: { id: pending.id } });

    try {
        await ctx.telegram.sendMessage(Number(pending.ownerId),
            `âœ… Ù¾Ø±ÙˆÚ˜Ù‡ "${pending.name}" ØªØ£ÛŒÛŒØ¯ Ø´Ø¯ Ùˆ Ø¨Ù‡ Ù„ÛŒØ³Øª Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§ÛŒ ÙØ¹Ø§Ù„ Ø´Ù…Ø§ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯.\n` +
            `ğŸ’° Ø¨ÙˆØ¯Ø¬Ù‡: ${Math.floor(Number(pending.setupCost) / 1_000_000)}M\n` +
            `â• Ø³ÙˆØ¯ Ø±ÙˆØ²Ø§Ù†Ù‡: ${Math.floor(profitAmount / 1_000_000)}M Ø¨Ù‡ Ø­Ø³Ø§Ø¨ Ø³ÙˆØ¯ Ø´Ù…Ø§ Ø§ÙØ²ÙˆØ¯Ù‡ Ø´Ø¯.`
        );
    } catch (err) {
        console.warn('âŒ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø± Ù…Ù…Ú©Ù† Ù†Ø¨ÙˆØ¯:', err);
    }
    if (pending.adminChatId && pending.adminMessageId) {
        await ctx.telegram.editMessageText(
            pending.adminChatId.toString(),
            pending.adminMessageId,
            undefined,
            'âœ… Ø§ÛŒÙ† Ù¾Ø±ÙˆÚ˜Ù‡ ØªØ£ÛŒÛŒØ¯ Ø´Ø¯ Ùˆ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ø«Ø¨Øª Ú¯Ø±Ø¯ÛŒØ¯.'
        );
    }

    await ctx.reply('âœ… Ù¾Ø±ÙˆÚ˜Ù‡ ØªØ£ÛŒÛŒØ¯ Ùˆ Ø«Ø¨Øª Ø´Ø¯.');
});
construction.action(/^admin_reject_construction_(\d+)$/, async (ctx) => {
    const pendingId = Number(ctx.match[1]);
    const adminId = ctx.from.id;

    if (!admins.includes(adminId)) {
        return ctx.answerCbQuery('â›” ÙÙ‚Ø· Ø§Ø¯Ù…ÛŒÙ† Ù…ÛŒâ€ŒØªÙˆÙ†Ù‡ Ø±Ø¯ Ú©Ù†Ù‡.');
    }

    const pending = await prisma.pendingProductionLine.findUnique({ where: { id: pendingId } });
    if (!pending) return ctx.answerCbQuery('âŒ Ù¾Ø±ÙˆÚ˜Ù‡ ÛŒØ§ÙØª Ù†Ø´Ø¯.');
    const now = new Date();
    if (pending.expiresAt && pending.expiresAt < now) {
        return ctx.reply('â›” Ø§ÛŒÙ† Ù¾Ø±ÙˆÚ˜Ù‡ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ùˆ Ù‚Ø§Ø¨Ù„ ØªØ£ÛŒÛŒØ¯ Ù†ÛŒØ³Øª.');
    }

    const refund = Number(pending.setupCost);
    const result = await changeCapital(pending.ownerId, 'add', refund);
    if (result !== 'ok') return ctx.answerCbQuery('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† Ø³Ø±Ù…Ø§ÛŒÙ‡.');

    await prisma.pendingProductionLine.delete({ where: { id: pendingId } });

    try {
        await ctx.telegram.sendMessage(Number(pending.ownerId),
            `âŒ Ù¾Ø±ÙˆÚ˜Ù‡ "${pending.name}" ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ† Ø±Ø¯ Ø´Ø¯.\nğŸ’¸ Ù…Ø¨Ù„Øº ${Math.floor(refund / 1_000_000)}M Ø¨Ù‡ Ø­Ø³Ø§Ø¨ Ø´Ù…Ø§ Ø¨Ø±Ú¯Ø´Øª Ø¯Ø§Ø¯Ù‡ Ø´Ø¯.`
        );
    } catch (err) {
        console.warn('âŒ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø± Ù…Ù…Ú©Ù† Ù†Ø¨ÙˆØ¯:', err);
    }

    if (pending.adminChatId && pending.adminMessageId) {
        await ctx.telegram.editMessageText(
            pending.adminChatId.toString(),
            pending.adminMessageId,
            undefined,
            'âŒ Ø§ÛŒÙ† Ù¾Ø±ÙˆÚ˜Ù‡ Ø±Ø¯ Ø´Ø¯ Ùˆ Ø¨Ø³ØªÙ‡ Ø´Ø¯.'
        );
    }

    await ctx.answerCbQuery('âœ… Ù¾Ø±ÙˆÚ˜Ù‡ Ø±Ø¯ Ø´Ø¯.');
});

export default construction;

mored ha be in sorat ast:
1. moghee essal matn new construction error : there is no text in the message to edit migiram
2.braye forosh mashin hast :
import { Composer, Markup } from 'telegraf';
import type { CustomContext } from '../middlewares/userAuth';
import { prisma } from '../prisma';
import { changeCapital } from './economy';
import { escapeMarkdownV2 } from '../utils/escape';

const products = new Composer<CustomContext>();

// Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚ÛŒÙ…Øª ÙØ±ÙˆØ´ Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ø±Ø§Ù†ÛŒ
function calculateSellPrice(prod: {
    type: string;
    unitPrice?: number | null;
    dailyOutput: number;
    setupCost: bigint;
    profitPercent?: number | null;
}): number {
    if (prod.type === 'car') {
        return (prod.unitPrice ?? 0) * prod.dailyOutput;
    }
    const base = Number(prod.setupCost);
    const profit = Math.floor(base * (prod.profitPercent ?? 0) / 100);
    return base + profit;
}

// Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ø®Ø·ÙˆØ· ØªÙˆÙ„ÛŒØ¯
products.action('products', async (ctx) => {
    const userId = BigInt(ctx.from.id);
    const lines = await prisma.productionLine.findMany({ where: { ownerId: userId , type: 'car' } });

    if (lines.length === 0) {
        const keyboard = Markup.inlineKeyboard([
            [Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'back_main')]
        ]);
        await ctx.reply('âŒ Ø´Ù…Ø§ Ù‡ÛŒÚ† Ø®Ø· ØªÙˆÙ„ÛŒØ¯ ÙØ¹Ø§Ù„ÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯.', keyboard);
        return ctx.answerCbQuery();
    }

    const rows = lines.map((line) => {
        const price = line.type === 'car'
            ? (line.unitPrice ?? 0)
            : Math.floor(Number(line.setupCost) * (line.profitPercent ?? 0) / 100);

        return [
            Markup.button.callback(`ğŸ­ ${line.name}`, 'noop'),
            Markup.button.callback(`ğŸ’° ${Math.floor(price / 1_000_000)}M`, 'noop'),
            Markup.button.callback(`ğŸ”„ ${line.dailyLimit}`, 'noop'),
            Markup.button.callback('ğŸ‘ Ù†Ù…Ø§ÛŒØ´', `show_${line.id}`)
        ];
    });

    rows.push([Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'back_main')]);

    await ctx.reply('ğŸ“¦ Ù„ÛŒØ³Øª Ø®Ø·ÙˆØ· ØªÙˆÙ„ÛŒØ¯ ÙØ¹Ø§Ù„ Ø´Ù…Ø§:', {
        reply_markup: Markup.inlineKeyboard(rows).reply_markup
    });

    ctx.answerCbQuery();
});

// Ù†Ù…Ø§ÛŒØ´ Ù¾Ù†Ù„ Ø¬Ø²Ø¦ÛŒØ§Øª Ù‡Ø± Ø®Ø· ØªÙˆÙ„ÛŒØ¯
products.action(/^show_(\d+)$/, async (ctx) => {
    const lineId = Number(ctx.match[1]);
    const userId = BigInt(ctx.from.id);
    const line = await prisma.productionLine.findUnique({ where: { id: lineId } });
    if (!line || line.ownerId !== userId) return ctx.answerCbQuery('âŒ Ø®Ø· ØªÙˆÙ„ÛŒØ¯ ÛŒØ§ÙØª Ù†Ø´Ø¯.');

    const unitPrice = line.type === 'car'
        ? (line.unitPrice ?? 0)
        : Math.floor(Number(line.setupCost) * (line.profitPercent ?? 0) / 100);

    const totalPrice = unitPrice * line.dailyOutput;

    const caption = escapeMarkdownV2(
        `ğŸ“¦ ${line.name} (${line.type})\n\n` +
        `ğŸ’° Ù‚ÛŒÙ…Øª ÙˆØ§Ø­Ø¯: ${Math.floor(unitPrice / 1_000_000)}M\n` +
        `ğŸ’° Ù‚ÛŒÙ…Øª Ú©Ù„: ${Math.floor(totalPrice / 1_000_000)}M\n\n` +
        `ğŸ”„ Ø¹Ù…Ø± Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡: ${line.dailyLimit} Ø±ÙˆØ²\n` +
        `ğŸš— Ø®Ø±ÙˆØ¬ÛŒ Ø§Ù…Ø±ÙˆØ²: ${line.dailyOutput} ÙˆØ§Ø­Ø¯`
    );

    const keyboard = Markup.inlineKeyboard([
        [
            Markup.button.callback(`ğŸ”„ Ø¹Ù…Ø±: ${line.dailyLimit} Ø±ÙˆØ²`, 'noop'),
            Markup.button.callback(`ğŸš— Ø®Ø±ÙˆØ¬ÛŒ: ${line.dailyOutput}`, 'noop')
        ],
        [
            Markup.button.callback(`ğŸ’µ Ø§Ø±Ø²Ø´ ÙˆØ§Ø­Ø¯: ${Math.floor(unitPrice / 1_000_000)}M`, 'noop'),
            Markup.button.callback(`ğŸ’µ Ø§Ø±Ø²Ø´ Ú©Ù„: ${Math.floor(totalPrice / 1_000_000)}M`, 'noop')
        ],
        [
            Markup.button.callback('ğŸ§¾ ÙØ±ÙˆØ´ Ù…Ø­ØµÙˆÙ„', 'noop')
        ],
            [Markup.button.callback('ğŸ“¤ ÙØ±ÙˆØ´ Ù‡Ù…Ù‡', `sell_all_${line.id}`),Markup.button.callback('ğŸ“¤ ÙØ±ÙˆØ´ ØªØ¹Ø¯Ø§Ø¯', `sell_one_${line.id}`)],
        [
            Markup.button.callback('âŒ Ø¨Ø³ØªÙ†', 'delete'),
            Markup.button.callback('ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª', 'products')
        ]
    ]);

    await ctx.reply(caption, {
        parse_mode: 'MarkdownV2',
        reply_markup: keyboard.reply_markup
    });

    ctx.answerCbQuery();
});

// ÙØ±ÙˆØ´ Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ø±Ø§Ù†ÛŒ Ø¨Ù‡ ØªØ¹Ø¯Ø§Ø¯ Ø¯Ù„Ø®ÙˆØ§Ù‡
products.action(/^sell_one_(\d+)$/, async (ctx) => {
    const lineId = Number(ctx.match[1]);
    const userId = BigInt(ctx.from.id);
    const line = await prisma.productionLine.findUnique({ where: { id: lineId } });
    if (!line || line.ownerId !== userId || line.type === 'car') return ctx.answerCbQuery('âŒ Ø®Ø· ØªÙˆÙ„ÛŒØ¯ Ø¹Ù…Ø±Ø§Ù†ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯.');

    ctx.session ??= {};
    ctx.session.sellLineId = lineId;
    ctx.session.sellStep = 'awaiting_sell_count';

    await ctx.reply(`ğŸ“¦ "${line.name}"\nğŸ”¢ Ú†Ù†Ø¯ ÙˆØ§Ø­Ø¯ Ù…ÛŒâ€ŒØ®ÙˆØ§ÛŒ Ø¨ÙØ±ÙˆØ´ÛŒØŸ (Ø­Ø¯Ø§Ú©Ø«Ø± ${line.dailyLimit})`);
    ctx.answerCbQuery();
});

// Ø¯Ø±ÛŒØ§ÙØª ØªØ¹Ø¯Ø§Ø¯ ÙØ±ÙˆØ´ Ø§Ø² Ú©Ø§Ø±Ø¨Ø±
products.on('text', async (ctx, next) => {
    ctx.session ??= {};

    if (ctx.session.sellStep === 'awaiting_sell_count') {
        const raw = ctx.message.text?.trim();
        const count = Number(raw.replace(/[^\d]/g, ''));
        if (isNaN(count) || count <= 0) return ctx.reply('âŒ Ø¹Ø¯Ø¯ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.');

        const lineId = ctx.session.sellLineId;
        const userId = BigInt(ctx.from.id);
        const line = await prisma.productionLine.findUnique({ where: { id: lineId } });
        if (!line || line.ownerId !== userId || line.type === 'car') return ctx.reply('âŒ Ø®Ø· ØªÙˆÙ„ÛŒØ¯ Ø¹Ù…Ø±Ø§Ù†ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯.');

        if (count > line.dailyLimit) {
            return ctx.reply(`âŒ ØªØ¹Ø¯Ø§Ø¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² Ø¸Ø±ÙÛŒØª Ø±ÙˆØ²Ø§Ù†Ù‡ Ø§Ø³Øª.\nğŸ”„ Ø¸Ø±ÙÛŒØª: ${line.dailyLimit}`);
        }

        const unitPrice = Math.floor(Number(line.setupCost) * (line.profitPercent ?? 0) / 100);
        const total = unitPrice * count;

        const result = await changeCapital(userId, 'add', total);
        if (result !== 'ok') return ctx.reply('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ù†ØªÙ‚Ø§Ù„ Ø³Ø±Ù…Ø§ÛŒÙ‡.');

        await prisma.productionLine.update({
            where: { id: lineId },
            data: { dailyLimit: { decrement: count } }
        });

        ctx.session.sellStep = undefined;
        ctx.session.sellLineId = undefined;

        await ctx.reply(`âœ… ${count} ÙˆØ§Ø­Ø¯ Ø§Ø² "${line.name}" ÙØ±ÙˆØ®ØªÙ‡ Ø´Ø¯.\nğŸ’° ${Math.floor(total / 1_000_000)}M Ø¨Ù‡ Ø­Ø³Ø§Ø¨ Ø´Ù…Ø§ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯.`);
        return;
    }

    return next();
});

// ÙØ±ÙˆØ´ Ù‡Ù…Ù‡ Ø®ÙˆØ¯Ø±ÙˆÙ‡Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯Ø´Ø¯Ù‡ Ø§Ø² Ø¬Ø¯ÙˆÙ„ Car
products.action(/^sell_all_(\d+)$/, async (ctx) => {
    const lineId = Number(ctx.match[1]);
    const userId = BigInt(ctx.from.id);

    const line = await prisma.productionLine.findUnique({ where: { id: lineId } });
    if (!line || line.ownerId !== userId || line.type !== 'car') {
        return ctx.answerCbQuery('âŒ Ø®Ø· ØªÙˆÙ„ÛŒØ¯ Ø®ÙˆØ¯Ø±Ùˆ ÛŒØ§ÙØª Ù†Ø´Ø¯.');
    }

    const cars = await prisma.car.findMany({
        where: {
            ownerId: userId,
            lineId: lineId,
            name: line.name,
            imageUrl: line.imageUrl
        }
    });

    if (cars.length === 0) {
        return ctx.answerCbQuery('âŒ Ù‡ÛŒÚ† Ø®ÙˆØ¯Ø±ÙˆÛŒÛŒ Ø¨Ø±Ø§ÛŒ ÙØ±ÙˆØ´ Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª.');
    }

    const total = cars.reduce((sum, car) => sum + car.price, 0);

    const result = await changeCapital(userId, 'add', total);
    if (result !== 'ok') return ctx.answerCbQuery('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ù†ØªÙ‚Ø§Ù„ Ø³Ø±Ù…Ø§ÛŒÙ‡.');

    await prisma.car.deleteMany({
        where: {
            ownerId: userId,
            name: line.name,
            imageUrl: line.imageUrl,
            lineId: lineId
        }
    });

    await ctx.reply(
        `âœ… ${cars.length} Ø®ÙˆØ¯Ø±Ùˆ Ø§Ø² "${line.name}" ÙØ±ÙˆØ®ØªÙ‡ Ø´Ø¯.\n` +
        `ğŸ’° Ù…Ø¬Ù…ÙˆØ¹ Ø¯Ø±ÛŒØ§ÙØªÛŒ: ${Math.floor(total / 1_000_000)}M`
    );

    ctx.answerCbQuery();
});

export default products;

in bayad tedad output daily , total output haii ke dar dastres dare ro neshon bede ke nmide
va braye forosh ham har 2 btn forosh moshkel daran
